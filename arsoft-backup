#!/usr/bin/python
# -*- coding: utf-8 -*-
# kate: space-indent on; indent-width 4; mixedindent off; indent-mode python;

import sys
import argparse
from datetime import datetime
import os.path
from arsoft.backup.BackupApp import BackupApp
from arsoft.backup.BackupConfig import BackupConfig
from arsoft.backup.DiskManager import DiskManager
from arsoft.backup.FileList import FileList, FileListItem
from arsoft.backup.RepositoryFactory import RepositoryFactory
from arsoft.backup.rsync import Rsync
from arsoft.git.bundle import GitBundle
from arsoft.git.error import *

class ARSoftBackupApp(BackupApp):

    def __init__(self):
        BackupApp.__init__(self, 'arsoft-backup')
        self._verbose = False
        self._dryrun = False
        self._diskmgr = None
        
    def load_config(self, configdir):
        BackupApp.load_config(self, configdir)
        # in any case continue with the config we got
        self._diskmgr = DiskManager()
        return True
    
    def _check_config(self):
        ret = True
        backup_dir = self.config.backup_directory
        if backup_dir is None or len(backup_dir) == 0:
            sys.stderr.write('No backup directory configured in %s\n' % (self.config.main_conf) )
            ret = False
        if self._verbose:
            print(self.config)
        return ret
    
    def _mkdir(self, dir):
        ret = True
        if os.path.exists(dir):
            if not os.path.isdir(dir):
                sys.stderr.write('%s is not a directory\n' % (dir) )
                ret = False
        else:
            try:
                os.makedirs(dir)
            except IOError as e:
                sys.stderr.write('Failed to create directory %s; error %s\n' % (dir, str(e)) )
                ret = False
        return ret

    def _prepare_backup_dir(self):
        ret = True
        backup_dir = self.config.backup_directory
        if backup_dir is None or len(backup_dir) == 0:
            sys.stderr.write('No backup directory configured in %s\n' % (self.config.main_conf) )
            ret = False
        else:
            if Rsync.is_rsync_url(backup_dir):
                # assume the given URL is good
                pass
            else:
                if not self._mkdir(backup_dir):
                    ret = False
            if ret:
                if self.config.intermediate_backup_directory:
                    if not self._mkdir(self.config.intermediate_backup_directory):
                        ret = False
        return ret

    def _on_system_startup(self):
        if self.config.eject_unused_backup_discs:
            print('eject unused discs')
            if self._diskmgr.eject():
                ret = 0
            else:
                ret = 1
        else:
            # nothing to do here
            ret = 0
        return ret
    
    def _do_rsync(self):
        backup_dir = self.config.backup_directory
        if not self.config.use_filesystem_snapshots and self.config.use_timestamp_for_backup_dir:
            now = datetime.utcnow()
            nowstr = now.strftime(self.config.timestamp_format_for_backup_dir)
            backup_dir = os.path.join(backup_dir, nowstr)
        if backup_dir[-1] != '/':
            backup_dir += '/'

        # build the final filelist
        source_filelist = FileList()
        if self.config.filelist_include:
            source_filelist.append(self.config.filelist_include)
        source_filelist.append(self.intermediate_filelist)
        #print(source_filelist)

        if not source_filelist.empty():
            inst = Rsync(source=source_filelist, dest=backup_dir, delete=True, deleteExcluded=True, 
                         use_ssh=self.config.use_ssh_for_rsync, ssh_key=self.config.ssh_identity_file,
                         dryrun=self._dryrun, verbose=self._verbose)
            ret = inst.execute()
        else:
            # everything OK since there is nothing to do
            ret = True
        return ret
    
    def _git_backup_to_bundle(self, repository, bundle_file):
        ret = False
        if GitBundle.is_bundle(bundle_file):
            bundle = GitBundle(bundle_file, repository=repository, verbose=self._verbose)
            try:
                ret = bundle.update()
                if ret:
                    if self._verbose:
                        print('backup %s to %s - Updated' % (repository.root_directory, bundle.filename))
                else:
                    sys.stderr.write('backup %s to %s - Failed\n' % (repository.root_directory, bundle.filename))
            except (GitRepositoryError, GitBundleError) as e:
                sys.stderr.write('Failed to update bundle from repository %s; error %s\n' % (repository.root_directory, str(e)))
        else:
            try:
                bundle = repository.create_bundle(bundle_file, all=True)
                if self._verbose:
                    print('backup %s to %s - Created' % (repository.root_directory, bundle.filename))
                ret = True
            except (GitRepositoryError, GitBundleError) as e:
                sys.stderr.write('Failed to create bundle from repository %s; error %s\n' % (repository.root_directory, str(e)))
        return ret

    def _git_backup(self):
        ret = True
        backup_dir = self.config.intermediate_backup_directory
        if backup_dir is None:
            backup_dir = self.config.backup_directory

        base_directory = backup_dir
        backup_dir = os.path.join(backup_dir, 'git')
        if not self._mkdir(backup_dir):
            ret = False
        if ret:
            repo_backup_filelist = FileListItem(base_directory=base_directory)
            for repo_path in self.config.repository_list:
                repo = RepositoryFactory.create(repo_path, verbose=self._verbose)
                if repo:
                    if repo.valid:
                        bundle_file = os.path.join(backup_dir, repo.name + '.git_bundle')
                        if self._verbose:
                            print('backup %s to %s' % (repo_path, bundle_file))
                        if not self._git_backup_to_bundle(repo, bundle_file):
                            ret = False
                        else:
                            repo_backup_filelist.append(bundle_file)
                    else:
                        sys.stderr.write('Repository %s is invalid\n' % repo_path)
                        ret = False
                else:
                    sys.stderr.write('Failed to load repository %s\n' % repo_path)
                    ret = False
            #print(repo_backup_filelist)
            self.intermediate_filelist.append(repo_backup_filelist)
            #print(self.intermediate_filelist)
        return ret
    
    def _perform_backup(self):
        if not self._check_config():
            return 1
        disc_loaded = False
        disc_ready = False
        # load all available external discs
        if not self._diskmgr.is_disc_ready():
            if not self._diskmgr.load():
                sys.stderr.write('Failed to load external discs\n')
                ret = 1
            else:
                disc_loaded = True
                disc_ready = True
        else:
            disc_ready = True
        
        if disc_ready:
            disc_ready = self._prepare_backup_dir()
            
        if disc_ready:
            ret = 0
            # backup disc is already mounted by DiskManager/edskmgr
            # backup all repos first
            if not self._git_backup():
                sys.stderr.write('GIT backup with errors; continue\n')
                ret = 1

            # rsync to backup destination/backup_dir
            if not self._do_rsync():
                sys.stderr.write('rsync failed\n')
                ret = 1
            # create new snapshot of the disc
            # remove old snapshot from the disc

        if disc_loaded:
            if not self._diskmgr.eject():
                sys.stderr.write('Failed to eject external discs\n')
                ret = 1
        return ret

    def main(self, argv=None):
        #=============================================================================================
        # process command line
        #=============================================================================================
        parser = argparse.ArgumentParser(description='frontend for the AR Soft backup functionality.')
        parser.add_argument('-v', '--verbose', dest='verbose', action='store_true', help='enable verbose output of this script.')
        parser.add_argument('-n', '--dry-run', dest='dryrun', action='store_true', help='Don\'t actually run any commands; just print them.')

        parser.add_argument('-C', '--config-directory', dest='configdir', default='/etc/arsoft-backup', help='name of the directory containing the backup configuration.')
        parser.add_argument('--system-startup', dest='system_startup', action='store_true', help='prepare the backup discs after the system has been started.')
        parser.add_argument('--backup', dest='perform_backup', action='store_true', help='starts a new backup.')

        args = parser.parse_args()

        self._verbose = args.verbose
        self._dryrun = args.dryrun

        if not self.load_config(args.configdir):
            sys.stderr.write('Failed to load configuration from %s.\n' % (args.configdir)) 
            ret = 1
        else:
            if self._verbose:
                print(self.config)
            if args.system_startup:
                ret = self._on_system_startup()
            elif args.perform_backup:
                ret = self._perform_backup()
            else:
                sys.stderr.write('No operation specified.\n')
                ret = 1

        return ret


if __name__ == "__main__":
    app = ARSoftBackupApp()
    sys.exit(app.main(sys.argv))

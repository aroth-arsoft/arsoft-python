#!/usr/bin/python3
# -*- coding: utf-8 -*-
# kate: space-indent on; indent-width 4; mixedindent off; indent-mode python;

import sys
import argparse
import os.path

import arsoft.dnsutils
import dns
import dns.update
import dns.reversename
import dns.zone
import dns.rdtypes.ANY.CNAME
import dns.rdtypes.ANY.MX
import dns.rdtypes.ANY.NS
import dns.rdtypes.ANY.PTR
import dns.rdtypes.ANY.SOA
import dns.rdtypes.ANY.TXT
import dns.rdtypes.IN.A
import dns.rdtypes.IN.AAAA
import dns.rdtypes.IN.SRV
import socket
import datetime

def _is_hostaddr_equal(a, b):
    if a is None and b is None:
        ret = True
    else:
        if a is None or b is None:
            ret = False
        elif len(a) == len(b):
            ret = True
            for a_e in a:
                if a_e not in b:
                    ret = False
                    break
        else:
            ret = False
    return ret


class RecordFieldError(Exception):
    def __init__(self, key, rrtype):
        self.key = key
        self.rrtype = rrtype

class UnknownRRTypeError(Exception):
    def __init__(self, rrtype):
        self.rrtype = rrtype

class InvalidRecordNameError(Exception):
    def __init__(self, name, should_be):
        self.name = name
        self.should_be = should_be

class dns_update_app(object):
    class rdatatype:
        DKIM = 600
        DMARC = 601

    _APP_SPECIFIC_RRTYPES = {
        rdatatype.DKIM : 'DKIM',
        rdatatype.DMARC : 'DMARC'
        }
    _APP_SPECIFIC_RRTYPES_REV = dict((v,k) for k,v in _APP_SPECIFIC_RRTYPES.items())

    @staticmethod
    def rdatatype_to_text(rrtype):
        if rrtype in dns_update_app._APP_SPECIFIC_RRTYPES:
            return dns_update_app._APP_SPECIFIC_RRTYPES[rrtype]
        else:
            return dns.rdatatype.to_text(rrtype)

    @staticmethod
    def rdatatype_from_text(str):
        if str in dns_update_app._APP_SPECIFIC_RRTYPES_REV:
            return dns_update_app._APP_SPECIFIC_RRTYPES_REV[str]
        else:
            return dns.rdatatype.from_text(str)

    RDATA_ANY_FIELDS = [
        ('ttl', [] ),
        ]
    RDATA_FIELDS = {
        dns.rdatatype.AAAA:     [ ('addr', ['host', 'address'] ) ],
        dns.rdatatype.A:        [ ('addr', ['host', 'address'] ) ],
        dns.rdatatype.MX:       [ ('addr', ['host', 'address', 'exchange', 'ex'] ), ('priority', ['prio', 'preference'] ) ],
        dns.rdatatype.CNAME:    [ ('target', ['addr', 'host', 'address'] ) ],
        dns.rdatatype.PTR:      [ ('target', ['addr', 'host', 'address'] ) ],
        dns.rdatatype.NS:       [ ('target', ['addr', 'host', 'address'] ) ],
        dns.rdatatype.TXT:      [ ('txt', [] ) ],
        dns.rdatatype.SOA:      [
                                  ('mname', ['master'] ),
                                  ('rname', ['admin'] ),
                                  ('serial', ['sn'] ),
                                  ('refresh', ['ref', 'ttl'] ),
                                  ('retry', ['ret'] ),
                                  ('expire', ['ex'] ),
                                  ('minimum', ['min'] ),
                                  ],
        dns.rdatatype.SRV:      [
                                  ('priority', [] ),
                                  ('weight', [] ),
                                  ('port', [] ),
                                  ('target', ['addr', 'host', 'address'] ),
                                  ],
        rdatatype.DKIM:         [
                                  ('p', ['key', 'public', 'publickey'] ),
                                  ('v', ['version'] ),
                                  ('kf', ['keyfile', 'file'] ),
                                  ('k', ['type'] ),
                                  ],
        rdatatype.DMARC:         [
                                  ('p', ['policy'] ),
                                  ('sp', ['subpolicy'] ),
                                  ('v', ['version'] ),
                                  ('pct', ['percent', 'percentage'] ),
                                  ('ruf', [] ),
                                  ('rua', [] ),
                                  ('adkim', ['dkim'] ),
                                  ('aspf', ['spf'] ),
                                  ],
        }

    DEFAULT_RRTYPE = 'A'
    DEFAULT_TTL = 86400
    DEFAULT_KEYFILE = None
    DEFAULT_TIMEOUT = 5
    HELP_NOTES = """
NOTE:
    If no DNS server is specified the default DNS server is used.
"""
    HELP_EXAMPLES = """
Examples:
    Add an A-record:
    dns-update --server 127.0.0.1 -a mail.example.com.=127.0.0.2
    Add an CNAME-record:
    dns-update --server 127.0.0.1 -a smtp.example.com.=mail.example.com./CNAME
    Update an internet (IN) class A-record:
    dns-update --server 127.0.0.1 -u mail.example.com.=127.0.0.3/A:IN
    Update an NS-record:
    dns-update --server 127.0.0.1 -u 'example.com.=first.example.com.|second.example.com./NS'
    Update an SOA-record:
    dns-update --server 127.0.0.1 -u example.com.=admin=admin.example.com.,ttl=86400/SOA
    dns-update --server 127.0.0.1 -u example.com.=master:ns1.example.com.,ttl:86400/SOA
    Add SPF TXT record:
    dns-update --server 127.0.0.1 -a "example.com.=v=spf1 include:_spf.google.com ~all/TXT"
    Update an DKIM TXT-record:
    dns-update --server 127.0.0.1 -u mail._domainkey.example.com.=key:MCQwDQYJKoZIhvcNAQEBBQADEwAwEAIJALkflXvQub5DAgMBAAE=/DKIM
    dns-update --server 127.0.0.1 -u mail._domainkey.example.com.=keyfile:~/dkim_publickey.pem/DKIM
    Update an DMARC TXT-record:
    dns-update --server 127.0.0.1 -u _dmarc.example.com.=p:reject/DMARC
"""

    def __init__(self):
        self.verbose = False
        self._updates = {}

    class arg_data(object):
        def __init__(self, arg):
            self._name = None
            self._server = None
            self._valid = False
            self._rrtype = None
            self._ttl = None
            self._classtype = None

            arg_name = None
            arg_server = None
            arg_rrtype = None
            arg_classtype = None
            arg_value = None
            arg_oldvalue = None
            arg_classtype = 'IN'

            i = arg.rfind('/')
            if i >= 0:
                arg_rrtype = arg[i+1:]
                arg = arg[0:i]
                if ':' in arg_rrtype:
                    arg_rrtype, arg_classtype = arg_rrtype.split(':', 1)
                try:
                    arg_rrtype = dns_update_app.rdatatype_from_text(arg_rrtype)
                except dns.exception.SyntaxError as e:
                    arg_rrtype = None
                except dns.rdatatype.UnknownRdatatype as e:
                    raise UnknownRRTypeError(arg_rrtype)
            else:
                arg_rrtype = dns_update_app.rdatatype_from_text('A')

            if arg_rrtype not in dns_update_app.RDATA_FIELDS:
                raise NotImplementedError('DNS record type %s not implemented' % arg_rrtype)

            #print('arg_rrtype=%i' % arg_rrtype)

            arg_field_map = {}
            arg_field_index_map = []
            for main_name, alt_names in dns_update_app.RDATA_FIELDS[arg_rrtype]:
                arg_field_map[main_name] = main_name
                arg_field_index_map.append(main_name)
                for a in alt_names:
                    arg_field_map[a] = main_name
            for main_name, alt_names in dns_update_app.RDATA_ANY_FIELDS:
                if main_name not in arg_field_map:
                    arg_field_map[main_name] = main_name
                for a in alt_names:
                    if a not in arg_field_map:
                        arg_field_map[a] = main_name
            #print('arg_field_map=%s' % arg_field_map)
            #print('arg_field_index_map=%s' % arg_field_index_map)

            if arg[0] == '@':
                arg_server = arg[1:]
            else:
                i = arg.find('=')
                if i >= 0:
                    arg_name = arg[0:i]
                    arg_value = arg[i+1:]
                    arg_dict = {}
                    arg_olddict = {}

                    if ('=' in arg_value or ':' in arg_value) and (arg_rrtype != dns.rdatatype.TXT and arg_rrtype != dns.rdatatype.AAAA):
                        for v in arg_value.split(','):
                            v_name = None
                            v_val = None
                            # DO NOT allow equal char in DKIM arguments because the key is base64 encoded
                            # and it might end with one or more padding '=' chars.
                            if '=' in v and arg_rrtype != app.rdatatype.DKIM:
                                v_name, v_val = v.split('=')
                            elif ':' in v:
                                v_name, v_val = v.split(':')

                            if v_name is None:
                                key = arg_field_index_map[0]
                                if arg_value:
                                    arg_dict[key] = arg_value
                            else:
                                if v_name in arg_field_map:
                                    key = arg_field_map[v_name]
                                else:
                                    raise RecordFieldError(v_name, arg_rrtype)

                                if '|' in v_val:
                                    old, new = v_val.split('|', 1)
                                    if old:
                                        arg_olddict[key] = old
                                    if new:
                                        arg_dict[key] = new
                                elif v_val:
                                    arg_dict[key] = v_val
                    elif (',' in arg_value or ' ' in arg_value) and (arg_rrtype != dns.rdatatype.TXT and arg_rrtype != dns.rdatatype.AAAA):
                        arg_value_split = arg_value.split(',') if ',' in arg_value else arg_value.split(' ')
                        arg_list = []
                        arg_oldlist = []
                        for e in arg_value_split:
                            if '|' in e:
                                old, new = e.split('|', 1)
                                arg_oldlist.append(old)
                                arg_list.append(new)
                            else:
                                arg_list.append(e)
                        for idx, a in enumerate(arg_list):
                            key = arg_field_index_map[idx]
                            if a:
                                arg_dict[key] = a
                        for idx, a in enumerate(arg_oldlist):
                            key = arg_field_index_map[idx]
                            if a:
                                arg_olddict[key] = a
                    elif '|' in arg_value:
                        key = arg_field_index_map[0]
                        old, new = arg_value.split('|', 1)
                        if old:
                            arg_olddict[key] = old
                        if new:
                            arg_dict[key] = new
                    else:
                        key = arg_field_index_map[0]
                        if arg_value:
                            arg_dict[key] = arg_value

                    arg_value = arg_dict if arg_dict else None
                    arg_oldvalue = arg_olddict if arg_olddict else None
                else:
                    arg_name = arg

            #print('>> got arg %s, %s, \'%s\'' % (arg_name, arg_rrtype, arg_value))
            if arg_name is not None and arg_rrtype is not None:
                try:
                    self._name = dns.name.from_text(arg_name)
                    self._valid = True
                except dns.exception.SyntaxError as e:
                    pass

            if arg_server is not None and arg_rrtype is not None:
                try:
                    self._server = dns.name.from_text(arg_server)
                    self._valid = True
                except dns.exception.SyntaxError as e:
                    pass
            self._rrtype = arg_rrtype
            self._classtype = arg_classtype
            self._value = arg_value
            self._oldvalue = arg_oldvalue
            if self._valid:
                self._ttl = self._get_item('ttl', None, old=False)

            self._check_record()

        def _check_record(self):
            ret = True
            if self._rrtype == dns_update_app.rdatatype.DKIM:
                elems = str(self._name).split('.')
                if elems[1] != '_domainkey':
                    elems[0] = '_domainkey'
                    raise InvalidRecordNameError(self._name, should_be='.'.join(elems))
            elif self._rrtype == dns_update_app.rdatatype.DMARC:
                elems = str(self._name).split('.')
                if elems[0] != '_dmarc':
                    elems[0] = '_dmarc'
                    raise InvalidRecordNameError(self._name, should_be='.'.join(elems))

        @property
        def valid(self):
            return self._valid

        @property
        def rrtype(self):
            if self._rrtype is None:
                return None
            return dns_update_app.rdatatype_to_text(self._rrtype)

        @property
        def ttl(self):
            return self._ttl if self._ttl is not None else dns_update_app.DEFAULT_TTL

        @property
        def name(self):
            return self._name.to_text()

        @property
        def has_server(self):
            return True if self._server is not None else False

        @property
        def server(self):
            return self._server.to_text()

        @property
        def raw(self):
            return '%s %s %s %s=%s' % (self._name.to_text(), self._classtype, self.rrtype, self._oldvalue, self._value)

        @property
        def value(self):
            values = []
            for (k, v) in self._value.items():
                values.append(str(v))
            return ' '.join(values)

        @property
        def has_old_value(self):
            return True if self._oldvalue is not None else False

        def __str__(self):
            if self._rrtype:
                return self.name + ' ' + self.value + '/' + self.rrtype
            else:
                return self.name + ' ' + self.value

        def missing_fields(self, old=False):
            ret = []
            fields = dns_update_app.RDATA_FIELDS[self._rrtype]
            for main_name, alt_names in fields:
                if self._value is None or main_name not in self._value:
                    ret.append(main_name)
            return ret

        def _get_item(self, key, default_value=None, old=False):
            target_type = None if default_value is None else type(default_value)
            if old:
                if key in self._oldvalue:
                    return target_type(self._oldvalue[key]) if target_type is not None else self._oldvalue[key]
            else:
                if key in self._value:
                    #print('_get_item %s->%s' % (key,self._value[key]))
                    return target_type(self._value[key]) if target_type is not None else self._value[key]
            return default_value

        def to_payload(self, old=False):
            if self._rrtype is None:
                return None, None
            elif self._rrtype == dns.rdatatype.A:
                addr = self._get_item('addr', None, old=old)
                return dns.rdtypes.IN.A.A(dns.rdataclass.IN, dns.rdatatype.A, addr)

            elif self._rrtype == dns.rdatatype.AAAA:
                addr = self._get_item('addr', None, old=old)
                return dns.rdtypes.IN.AAAA.AAAA(dns.rdataclass.IN, dns.rdatatype.AAAA, addr)

            elif self._rrtype == dns.rdatatype.MX:
                addr = self._get_item('addr', None, old=old)
                priority = self._get_item('priority', 10, old=old)
                return dns.rdtypes.ANY.MX.MX(dns.rdataclass.IN, dns.rdatatype.MX, priority, addr)

            elif self._rrtype == dns.rdatatype.PTR:
                target = self._get_item('target', None, old=old)
                return dns.rdtypes.ANY.PTR.PTR(dns.rdataclass.IN, dns.rdatatype.PTR, target)

            elif self._rrtype == dns.rdatatype.CNAME:
                target = self._get_item('target', None, old=old)
                return dns.rdtypes.ANY.CNAME.CNAME(dns.rdataclass.IN, dns.rdatatype.CNAME, target)

            elif self._rrtype == dns.rdatatype.NS:
                target = self._get_item('target', None, old=old)
                return dns.rdtypes.ANY.NS.NS(dns.rdataclass.IN, dns.rdatatype.NS, target)

            elif self._rrtype == dns.rdatatype.TXT:
                text = self._get_item('text', None, old=old)
                return dns.rdtypes.ANY.TXT.TXT(dns.rdataclass.IN, dns.rdatatype.TXT, text)

            elif self._rrtype == dns.rdatatype.SOA:
                mname = self._get_item('mname', 'master.%s' % self.name, old=old)
                rname = self._get_item('rname', 'hostmaster.%s' % self.name, old=old)

                serial = self._get_item('serial', None, old=old)
                if serial is None:
                    now = datetime.datetime.now()
                    serial = int('%04i%02i%02i%02i' % (now.year, now.month, now.day, now.hour))
                refresh = self._get_item('refresh', self.ttl, old=old)
                retry = self._get_item('retry', self.ttl / 24, old=old)
                expire = self._get_item('expire', self.ttl, old=old)
                minimum = self._get_item('minimum', self.ttl / 48, old=old)
                return dns.rdtypes.ANY.SOA.SOA(dns.rdataclass.IN, dns.rdatatype.SOA, mname, rname, serial, refresh, retry, expire, minimum)

            elif self._rrtype == dns.rdatatype.SRV:
                priority = self._get_item('priority', 10, old=old)
                weight = self._get_item('weight', 0, old=old)
                port = self._get_item('port', None, old=old)
                target = self._get_item('target', None, old=old)
                return dns.rdtypes.IN.SRV.SRV(dns.rdataclass.IN, dns.rdatatype.SRV, priority, weight, port, target) if port is not None and target is not None else None

            elif self._rrtype == app.rdatatype.DKIM:
                version = self._get_item('v', 'DKIM1', old=old)
                keytype = self._get_item('k', 'rsa', old=old)
                key = self._get_item('p', None, old=old)
                keyfile = self._get_item('kf', None, old=False)
                if key is None and keyfile is not None:
                    import arsoft.crypto
                    keyfile = os.path.expanduser(keyfile)
                    pemfile = arsoft.crypto.PEMFile()
                    if pemfile.open(keyfile) and pemfile.valid:
                        #print(pemfile)
                        for pemitem in pemfile.getBlocks('PUBLIC KEY'):
                            key = "".join(line.strip() for line in pemitem.rawblockdata)
                        pemfile.close()
                        if key is None:
                            raise IOError('Unable to load public key from %s' % (keyfile) )
                    else:
                        raise IOError('Unable to read %s, error %s' % (keyfile, pemfile.last_error) )
                    #print('key: %s' % key)
                if key is None:
                    return None
                full_string = ('v=%s; k=%s; p=%s;' % (version, keytype, key)).encode('ascii')
                strings = [full_string[i:i+250] for i in range(0, len(full_string), 250)]
                return dns.rdtypes.ANY.TXT.TXT(dns.rdataclass.IN, dns.rdatatype.TXT, strings)
            elif self._rrtype == app.rdatatype.DMARC:
                version = self._get_item('v', 'DMARC1', old=old)
                percentage = self._get_item('pct', '100', old=old)
                ruf = self._get_item('ruf', None, old=old)
                rua = self._get_item('rua', None, old=old)
                policy = self._get_item('p', 'none', old=old)
                subpolicy = self._get_item('sp', 'none', old=old)
                adkim = self._get_item('adkim', None, old=old)
                aspf = self._get_item('aspf', None, old=old)
                props = ['v=%s' % version,
                         'p=%s' % policy,
                         'sp=%s' % subpolicy,
                         'pct=%s' % percentage
                         ]
                if ruf:
                    props.append('ruf=%s' % ruf)
                if rua:
                    props.append('rua=%s' % rua)
                if adkim:
                    props.append('adkim=%s' % adkim)
                if aspf:
                    props.append('aspf=%s' % aspf)
                full_string = '; '.join(props).encode('ascii')
                strings = [full_string[i:i+250] for i in range(0, len(full_string), 250)]
                return dns.rdtypes.ANY.TXT.TXT(dns.rdataclass.IN, dns.rdatatype.TXT, strings)
            else:
                raise NotImplementedError

        def _set_missing_item(self, key, value, index=None):
            ret = False
            if self._value is None:
                self._value = {}
            if not key in self._value:
                #print('_set_missing_item %s=%s' % (key,value))
                self._value[key] = value
                ret = True
            return ret

        def fetch_current(self, resolver):
            if self._rrtype is None:
                return None

            try:
                #print('fetch_current %s %s' % (self._rrtype, self._name) )
                answers = resolver.query(self._name, self._rrtype)
                for rdata in answers:
                    #print(rdata)
                    if self._rrtype == dns.rdatatype.A or self._rrtype == dns.rdatatype.AAAA:
                        self._set_missing_item('addr', rdata.address)
                    elif self._rrtype == dns.rdatatype.MX:
                        self._set_missing_item('addr', rdata.exchange)
                        self._set_missing_item('priority', rdata.preference)
                    elif self._rrtype == dns.rdatatype.CNAME:
                        self._set_missing_item('target', rdata.target)
                    elif self._rrtype == dns.rdatatype.NS:
                        self._set_missing_item('target', rdata.target)
                    elif self._rrtype == dns.rdatatype.SOA:
                        #print('got %s' % rdata)
                        self._set_missing_item('mname', rdata.mname)
                        self._set_missing_item('rname', rdata.rname)
                        # increment serial number by one
                        self._set_missing_item('serial', rdata.serial + 1)
                        self._set_missing_item('refresh', rdata.refresh)
                        self._set_missing_item('retry', rdata.retry)
                        self._set_missing_item('expire', rdata.expire)
                        self._set_missing_item('minimum', rdata.minimum)
            except dns.resolver.NoAnswer:
                #print('No answer')
                pass
            except dns.resolver.NXDOMAIN:
                #print('do domain')
                pass

    @staticmethod
    def _split_args(args):
        ok = True
        ret = []
        for arg in args:
            item = None
            try:
                item = dns_update_app.arg_data(arg)
            except RecordFieldError as e:
                sys.stderr.write("Parameter %s is not valid for DNS %s record \"%s\".\n" % (e.key, dns_update_app.rdatatype_to_text(e.rrtype), arg))
                ok = False
            except UnknownRRTypeError as e:
                sys.stderr.write("DNS RR type \"%s\" not supported\n" % (e.rrtype))
                ok = False
            except NotImplementedError as e:
                sys.stderr.write("Error processing parameter \"%s\": %s\n" % (arg, e))
                ok = False
            except InvalidRecordNameError as e:
                sys.stderr.write("Invalid record name \"%s\", should be \"%s\"\n" % (e.name, e.should_be))
                ok = False

            if item:
                if not item.valid:
                    sys.stderr.write("Invalid syntax for DNS record \"%s\".\n" % (arg))
                    ok = False
                else:
                    ret.append( item )
        if ok:
            return ret
        else:
            return None


    def _get_update_object(self, name):
        if name in self._updates:
            ret = self._updates[name]
        else:
            ret = None
            try:
                #print('name=%s' % name)
                Origin, dummy = arsoft.dnsutils.get_dns_zone_for_name(name, dnsserver=self.server, timeout=self.timeout)
                if Origin is not None:
                    for (update_name, update) in self._updates.items():
                        if update.origin == Origin:
                            return update
                    ret = dns.update.Update(Origin)
                    if self.keyfile:
                        if not arsoft.dnsutils.use_key_file(ret, self.keyfile, arsoft.dnsutils.KeyFileFormat.Automatic):
                            sys.stderr.write("Unable to load key file %s\n" % (self.keyfile))
                            ret = None
                    if ret:
                        self._updates[name] = ret
            except dns.resolver.NoNameservers as e:
                sys.stderr.write("No nameserver found for %s\n" % (name))
                ret = None
            except dns.exception.Timeout as e:
                sys.stderr.write("Unable to get DNS zone for %s after %s seconds\n" % (name, self.timeout))
                ret = None
        return ret

    def _add_record(self, args):
        if args is None:
            return False
        ret = True
        for arg in args:
            update = self._get_update_object(arg.name)
            if update is None:
                ret = False
            else:
                try:
                    payload = arg.to_payload(old=False)
                    if payload is None:
                        ret = False
                        sys.stderr.write("Unable to convert %s to DNS payload\n" % (arg.raw))
                        continue
                except IOError as e:
                    ret = False
                    sys.stderr.write("%s\n" % (e))
                    continue

                if arg.has_old_value:
                    sys.stderr.write("WARNING: given record has an old value. Use update instead of add operation to use the old value.\n")

                try:
                    update.add(arg.name, arg.ttl, payload)
                except dns.exception.SyntaxError as e:
                    sys.stderr.write("Syntax error \"%s\" for adding %s record %s: %s\n" % (e, arg.rrtype, arg.name, payload))
                    ret = False
        return ret

    def _delete_record(self, args):
        if args is None:
            return False
        ret = True
        for arg in args:
            update = self._get_update_object(arg.name)
            if update is None:
                ret = False
            else:
                try:
                    payload = arg.to_payload(old=False)
                    if payload is None:
                        ret = False
                        sys.stderr.write("Unable to convert %s to DNS payload\n" % (arg.raw))
                        continue
                except IOError as e:
                    ret = False
                    sys.stderr.write("%s\n" % (e))
                    continue

                try:
                    if payload is None:
                        update.delete(arg.name, arg.rrtype)
                    else:
                        update.delete(arg.name, payload)
                except dns.exception.SyntaxError as e:
                    sys.stderr.write("Syntax error \"%s\" for delete %s record %s: %s\n" % (e, arg.rrtype, arg.name, payload))
                    ret = False
        return ret

    def _update_record(self, args):
        if args is None:
            return False
        ret = True
        resolver=None
        for arg in args:
            update = self._get_update_object(arg.name)
            if update is None:
                ret = False
            else:
                if resolver is None:
                    resolver = arsoft.dnsutils._get_resolver(self.server, timeout=self.timeout)

                if arg.missing_fields():
                    arg.fetch_current(resolver=resolver)

                try:
                    payload = arg.to_payload(old=False)
                    if payload is None:
                        ret = False
                        sys.stderr.write("Unable to convert %s to DNS payload\n" % (arg.raw))
                        continue
                except IOError as e:
                    ret = False
                    sys.stderr.write("%s\n" % (e))
                    continue

                if arg.has_old_value:
                    try:
                        old_payload = arg.to_payload(old=True)
                        if old_payload is None:
                            ret = False
                            sys.stderr.write("Unable to convert %s to DNS old payload\n" % (arg.raw))
                            continue
                    except IOError as e:
                        ret = False
                        sys.stderr.write("%s\n" % (e))
                        continue

                    delete_ok = False
                    try:
                        update.delete(arg.name, old_payload)
                        delete_ok = True
                    except dns.exception.SyntaxError as e:
                        sys.stderr.write("Syntax error \"%s\" for delete %s record %s: %s\n" % (e, arg.rrtype, arg.name, old_payload))
                        ret = False
                    if delete_ok:
                        try:
                            update.add(arg.name, arg.ttl, payload)
                        except dns.exception.SyntaxError as e:
                            sys.stderr.write("Syntax error \"%s\" for adding %s record %s: %s\n" % (e, arg.rrtype, arg.name, payload))
                            ret = False
                else:
                    try:
                        update.replace(arg.name, arg.ttl, payload)
                    except dns.exception.SyntaxError as e:
                        sys.stderr.write("Syntax error \"%s\" for adding %s record %s: %s\n" % (e, arg.rrtype, arg.name, payload))
                        ret = False
        return ret

    def _update_host(self, args):
        if args is None:
            return False
        ret = True
        for arg in args:
            if isinstance(payload, list):
                addr_list = payload
            else:
                addr_list = payload.split(',')

            name = dns.name.from_text(name)
            update = self._get_update_object(host)
            if update is None:
                ret = False
            else:
                update.delete(name, self.rrtype)
                for addr in addr_list:
                    update.add(name, self.ttl, self.rrtype, addr)
                    if (self.rrtype == 'A' or self.rrtype == 'AAAA') and not self.no_reverse:
                        # delete reverse addr and re-add it afterwards
                        revaddrname = dns.reversename.from_address(addr)
                        Origin, dummy = arsoft.dnsutils.get_dns_zone_for_name(revaddrname)
                        #print(Origin, dummy)
                        rev_update = self._get_update_object(revaddrname)
                        if rev_update:
                            rev_update.delete(revaddrname, 'PTR')
                            rev_update.add(revaddrname, self.ttl, 'PTR', addr)
        return ret

    def _import_host(self, args):
        if args is None:
            return False
        anotherserver = None
        hosts_to_import = []

        for arg in args:
            if arg.has_server:
                anotherserver = arg.server
            else:
                hosts_to_import.append( arg )

        if anotherserver is None:
            sys.stderr.write("No DNS server to query specified.\n")
            ret = False
        else:
            ipv6 = True if self.rrtype == 'AAAA' else False
            ret = True
            for arg in hosts_to_import:
                host = arg.name
                rrtype = arg.rrtype

                target_hostaddr = None
                try:
                    target_hostaddr = arsoft.dnsutils.get_dns_host_record(host, ipv6=ipv6, dnsserver=self.server, timeout=self.timeout)
                except dns.resolver.NoAnswer as e:
                    sys.stderr.write("Failed to retrieve host record %s from target DNS server %s - no answer.\n" % (host, self.server))
                except dns.resolver.NXDOMAIN as e:
                    sys.stderr.write("Failed to retrieve host record %s from target DNS server %s - domain does not exist.\n" % (host, self.server))
                except dns.exception.Timeout as e:
                    sys.stderr.write("Failed to retrieve host record %s from target DNS server %s - timeout.\n" % (host, self.server))

                if target_hostaddr is None:
                    ret = False
                    sys.stderr.write("Failed to retrieve host record %s from target DNS server %s.\n" % (host, self.server))
                    continue

                anotherserver_hostaddr = None
                try:
                    anotherserver_hostaddr = arsoft.dnsutils.get_dns_host_record(host, ipv6=ipv6, dnsserver=anotherserver, timeout=self.timeout)
                except dns.resolver.NoAnswer as e:
                    sys.stderr.write("Failed to retrieve host record %s from remote DNS server %s - no answer.\n" % (host, anotherserver))
                except dns.resolver.NXDOMAIN as e:
                    sys.stderr.write("Failed to retrieve host record %s from remote DNS server %s - domain does not exist.\n" % (host, anotherserver))
                except dns.exception.Timeout as e:
                    sys.stderr.write("Failed to retrieve host record %s from remote DNS server %s - timeout.\n" % (host, anotherserver))

                if anotherserver_hostaddr is None:
                    ret = False
                    sys.stderr.write("Failed to retrieve host record %s from remote DNS server %s.\n" % (host, anotherserver))
                    continue

                if not _is_hostaddr_equal(target_hostaddr, anotherserver_hostaddr):
                    if self.verbose:
                        print("Update host record %s from %s to %s." % (host, target_hostaddr, anotherserver_hostaddr))
                    update_tuple = (host, anotherserver_hostaddr)
                    if not self._update_host( [ update_tuple ] ):
                        sys.stderr.write("Failed to update host record %s on target DNS server\n" % (host, self.server))
                        ret = False
                else:
                    if self.verbose:
                        print("Host record %s up-to-date %s<>%s." % (host, target_hostaddr, anotherserver_hostaddr))
        return ret

    def _dump_zone(self, zone):
        level = 0
        print("Zone origin: %s" % zone.origin)
        for name, node in list(zone.nodes.items()):
            level = 1
            indent = ' ' * (2*level)
            rdatasets = node.rdatasets
            print(indent + "node %s" % name)
            for rdataset in rdatasets:
                level = 2
                indent = ' ' * (2*level)
                print(indent + "rdataset string representation: %s" % str(rdataset))
                print(indent + "rdataset rdclass: %s" % dns.rdataclass.to_text(rdataset.rdclass))
                print(indent + "rdataset rdtype: %s" % dns_update_app.rdatatype_to_text(rdataset.rdtype))
                print(indent + "rdataset ttl: %i" % rdataset.ttl)
                for rdata in rdataset:
                    level = 3
                    indent = ' ' * (2*level)
                    print(indent + "rdata string representation: %s" % str(rdata))
                    print(indent + "** %s-specific rdata **" % dns_update_app.rdatatype_to_text(rdataset.rdtype) )
                    if rdataset.rdtype == dns.rdatatype.SOA:
                        print(indent + "expire: %i" % rdata.expire)
                        print(indent + "minimum: %i" % rdata.minimum)
                        print(indent + "mname: %s" % rdata.mname)
                        print(indent + "refresh: %i" % rdata.refresh)
                        print(indent + "retry: %i" % rdata.retry)
                        print(indent + "rname: %s" % rdata.rname)
                        print(indent + "serial: %s" % rdata.serial)
                    elif rdataset.rdtype == dns.rdatatype.MX:
                        print(indent + "exchange: %s" % rdata.exchange)
                        print(indent + "preference: %i" % rdata.preference)
                    elif rdataset.rdtype == dns.rdatatype.NS:
                        print(indent + "target: %s" % rdata.target)
                    elif rdataset.rdtype == dns.rdatatype.CNAME:
                        print(indent + "target: %s" % rdata.target)
                    elif rdataset.rdtype == dns.rdatatype.A:
                        print(indent + "address: %s" % rdata.address)
                    elif rdataset.rdtype == dns.rdatatype.AAAA:
                        print(indent + "address: %s" % rdata.address)
                    elif rdataset.rdtype == dns.rdatatype.TXT:
                        print(indent + "text: %s" % str(rdata.strings))
                    elif rdataset.rdtype == dns.rdatatype.SRV:
                        print(indent + "port: %i" % rdata.port)
                        print(indent + "priority: %i" % rdata.priority)
                        print(indent + "target: %s" % rdata.target)
                        print(indent + "weight: %i" % rdata.weight)
                    else:
                        print(indent + "data: %s" % str(rdata))

    def _update_file(self, args, origin=None):
        if args is None:
            return False
        ret = True
        for f in args:
            zone = None
            try:
                zone = dns.zone.from_file(f, origin=origin)
            except IOError as e:
                ret = False
                sys.stderr.write("Failed to read from zone file %s. Error %s\n" % (f, str(e)))
            except dns.zone.NoSOA as e:
                ret = False
                sys.stderr.write("Zone file %s does not contain a SOA record.\n" % (f))
            except dns.zone.NoNS as e:
                ret = False
                sys.stderr.write("Zone file %s does not contain a NS record for the SOA record.\n" % (f))
            except dns.exception.SyntaxError as e:
                ret = False
                sys.stderr.write("Zone file %s contains syntax error(s). %s\n" % (f, str(e)))
            if zone is None:
                continue
            if self.verbose:
                self._dump_zone(zone)
            for name, node in list(zone.nodes.items()):
                level = 1
                indent = ' ' * (2*level)
                rdatasets = node.rdatasets
                if self.verbose:
                    print(indent + "node %s" % name)
                for rdataset in rdatasets:
                    if rdataset.rdtype == dns.rdatatype.SOA:
                        # skip SOA
                        continue
                    elif rdataset.rdtype == dns.rdatatype.NS:
                        is_loopback_ns = False
                        for rdata in rdataset:
                            if str(rdata.target) == '127.0.0.1':
                                is_loopback_ns = True
                        if is_loopback_ns:
                            continue

                    full_node = dns.name.from_text(str(name), zone.origin)
                    update = self._get_update_object(full_node)
                    update.delete(full_node, rdataset)
                    update.add(full_node, rdataset)

        return ret

    def _lookup_hosts(self, args):

        ret = True
        dnsserver = self.server
        hosts_to_lookup = []
        for arg in args:
            if arg.has_server:
                dnsserver = arg.server
            else:
                hosts_to_lookup.append( arg )

        for arg in hosts_to_lookup:
            host = arg.name
            rrtype = arg.rrtype

            hostaddr = None
            try:
                resolver = arsoft.dnsutils._get_resolver(dnsserver, timeout=self.timeout)
                if resolver:
                    answers = resolver.query(arg.name, arg.rrtype)
                    for rdata in answers:
                        print(rdata)
                else:
                    ret = False
            except dns.resolver.NoAnswer as e:
                sys.stderr.write("Failed to retrieve %s record %s from DNS server %s - no answer.\n" % (arg.rrtype, arg.name, dnsserver))
                ret = False
            except dns.resolver.NXDOMAIN as e:
                sys.stderr.write("Failed to retrieve %s record %s from DNS server %s - domain does not exist.\n" % (arg.rrtype, arg.name, dnsserver))
                ret = False
            except dns.exception.Timeout as e:
                sys.stderr.write("Failed to retrieve %s record %s from DNS server %s - timeout.\n" % (arg.rrtype, arg.name, dnsserver))
                ret = False
        return ret

    def main(self):
        epilog = dns_update_app.HELP_NOTES
        for (rrtype, fields) in dns_update_app.RDATA_FIELDS.items():
            epilog += '%s record:\n' % dns_update_app.rdatatype_to_text(rrtype)
            for main_name, alt_names in fields:
                epilog += '  %s: %s\n' % (main_name, ','.join(alt_names))
        epilog += dns_update_app.HELP_EXAMPLES

        #=============================================================================================
        # process command line
        #=============================================================================================
        parser = argparse.ArgumentParser(description='add/update/delete the DNS information',
                                         formatter_class=argparse.RawDescriptionHelpFormatter,
                                         epilog=epilog)
        parser.add_argument('-v', '--verbose', dest='verbose', action='store_true', help='enable verbose output of this script.')
        parser.add_argument('--noop', dest='noop', action='store_true', help='no not actual update anything, just show what would be done.')
        parser.add_argument('--no-reverse', dest='no_reverse', action='store_true', help='no not automatically update PTR records for A/AAAA record.')
        parser.add_argument('--available', dest='available', action='store_true', help='checks if EFI is available on this machine.')
        parser.add_argument('--server', dest='server', help='name of the DNS server for updates')
        parser.add_argument('--rrtype', dest='rrtype', default=self.DEFAULT_RRTYPE, help='specify the RR type for the next operation')
        parser.add_argument('--ttl', dest='ttl', default=self.DEFAULT_TTL, help='specify the TTL for the records')
        parser.add_argument('-k', '--key', dest='keyfile', default=self.DEFAULT_KEYFILE, help='key to use for the update')
        parser.add_argument('-g', '--gssapi', dest='gssapi', action='store_true', help='use GSSAPI for authentication')
        parser.add_argument('-t', '--timeout', dest='timeout', default=self.DEFAULT_TIMEOUT, help='set the timeout for DNS queries and updates')

        parser.add_argument('-l', '--lookup', dest='lookup', nargs='+', help='look up the given DNS record')
        parser.add_argument('-a', '--add', dest='add', nargs='+', help='adds the given DNS record; name value')
        parser.add_argument('-d', '--delete', dest='delete', nargs='+', help='deletes the specified DNS record')
        parser.add_argument('-u', '--update', dest='update', nargs='+', help='updates the specified DNS record')
        parser.add_argument('--update-file', dest='update_file', nargs='+', help='load DNS records from the given files and update them.')
        parser.add_argument('--update-host', dest='update_host', nargs='+', help='updates the given host for the specified address.')
        parser.add_argument('--import-host', dest='import_host', nargs='+', help='import the result from the specified DNS server and update the local DNS server.')

        args = parser.parse_args()

        self.verbose = args.verbose
        self.noop = args.noop
        self.no_reverse = args.no_reverse
        self.ttl = args.ttl
        self.rrtype = args.rrtype
        if args.server is None:
            self.server = arsoft.dnsutils.get_default_dnsserver()
        else:
            self.server = args.server
        self.keyfile = args.keyfile
        self.timeout = args.timeout
        self.gssapi = args.gssapi

        perform_update = True

        if args.add:
            if not self._add_record(dns_update_app._split_args(args.add)):
                perform_update = False
        if args.delete:
            if not self._delete_record(dns_update_app._split_args(args.delete)):
                perform_update = False
        if args.update:
            if not self._update_record(dns_update_app._split_args(args.update)):
                perform_update = False

        if args.update_host:
            if not self._update_host(dns_update_app._split_args(args.update_host)):
                perform_update = False

        if args.update_file:
            if not self._update_file(args.update_file):
                perform_update = False

        if args.import_host:
            if not self._import_host(dns_update_app._split_args(args.import_host)):
                perform_update = False

        if args.lookup:
            if not self._lookup_hosts(dns_update_app._split_args(args.lookup)):
                perform_update = False

        if perform_update:
            if len(self._updates) == 0:
                if self.verbose:
                    print('Nothing to do.')
                ret = 0
            else:
                ret = 0
                for (host, update) in self._updates.items():
                    if self.verbose or self.noop:
                        print('update %s with:\n%s\n' % (host, update))
                    if not self.noop:
                        try:
                            response = dns.query.tcp(update, args.server)
                            if response:
                                if response.rcode() != dns.rcode.NOERROR:
                                    sys.stderr.write("Update %s failed with error %s\n" % (host, dns.rcode.to_text(response.rcode())) )
                                    ret = 1
                                else:
                                    if self.verbose:
                                        print('Update %s successful\n' % (host))
                            else:
                                sys.stderr.write("No response for update of %s\n" % (host) )
                                ret = 1
                        except socket.error as e:
                            sys.stderr.write("Network error on update %s: %s\n" % (host, str(e)) )
                            ret = 1

        else:
            ret = 1
        return ret

if __name__ == "__main__":
    app =  dns_update_app()
    sys.exit(app.main())

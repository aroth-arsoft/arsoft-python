#!/usr/bin/python3
# -*- coding: utf-8 -*-
# kate: space-indent on; indent-width 4; mixedindent off; indent-mode python;

import sys
import argparse

import arsoft.dnsutils
import dns
import dns.update
import dns.reversename
import dns.zone
import socket

def _is_hostaddr_equal(a, b):
    if a is None and b is None:
        ret = True
    else:
        if a is None or b is None:
            ret = False
        elif len(a) == len(b):
            ret = True
            for a_e in a:
                if a_e not in b:
                    ret = False
                    break
        else:
            ret = False
    return ret

class dns_update_app(object):

    DEFAULT_RRTYPE = 'A'
    DEFAULT_TTL = 86400
    DEFAULT_KEYFILE = None
    DEFAULT_TIMEOUT = 5
    SYNTAX_HELP = """
NOTE:
    If no DNS server is specified the default DNS server is used.

Examples:
    Add an A-record:
    dns-update --server 127.0.0.1 -a mail.example.com.=127.0.0.2
    Add an CNAME-record:
    dns-update --server 127.0.0.1 -a smtp.example.com.=mail.example.com./CNAME
    Update an internet (IN) class A-record:
    dns-update --server 127.0.0.1 -u mail.example.com.=127.0.0.3/A:IN
    Update an NS-record:
    dns-update --server 127.0.0.1 -u 'example.com.=first.example.com.|second.example.com./NS'
    Update an SOA-record:
    dns-update --server 127.0.0.1 -u example.com.=admin=admin.example.com.,ttl=86400/SOA
    dns-update --server 127.0.0.1 -u example.com.=master:ns1.example.com.,ttl:86400/SOA
    Add SPF TXT record:
    dns-update --server 127.0.0.1 -a "example.com.=v=spf1 include:_spf.google.com ~all/TXT"
    """

    def __init__(self):
        self.verbose = False
        self._updates = {}

    class arg_data(object):
        def __init__(self, arg):
            self._name = None
            self._server = None
            self._valid = False
            self._rrtype = None
            self._ttl = 0
            self._classtype = None

            arg_name = None
            arg_server = None
            arg_rrtype = None
            arg_classtype = None
            arg_value = None
            arg_oldvalue = None

            i = arg.rfind('/')
            if i >= 0:
                arg_rrtype = arg[i+1:]
                arg = arg[0:i]
                if ':' in arg_rrtype:
                    arg_rrtype, arg_classtype = arg_rrtype.split(':', 1)
                else:
                    arg_classtype = 'IN'
            if arg[0] == '@':
                arg_server = arg[1:]
            else:
                i = arg.find('=')
                if i >= 0:
                    arg_name = arg[0:i]
                    arg_value = arg[i+1:]

                    if ('=' in arg_value or ':' in arg_value) and arg_rrtype != 'TXT':
                        arg_dict = {}
                        arg_olddict = {}
                        for v in arg_value.split(','):
                            if '=' in v:
                                v_name, v_val = v.split('=')
                                arg_dict[v_name] = v_val
                            elif ':' in v:
                                v_name, v_val = v.split(':')
                                arg_dict[v_name] = v_val

                        arg_value = arg_dict
                    elif (',' in arg_value or ' ' in arg_value) and arg_rrtype != 'TXT':
                        arg_value_split = arg_value.split(',') if ',' in arg_value else arg_value.split(' ')
                        arg_list = []
                        arg_oldlist = []
                        for e in arg_value_split:
                            if '|' in e:
                                old, new = e.split('|', 1)
                                arg_oldlist.append(old)
                                arg_list.append(new)
                            else:
                                arg_list.append(e)
                        arg_value = arg_list if len(arg_list) else None
                        arg_oldvalue = arg_oldlist if len(arg_oldlist) else None
                    elif '|' in arg_value:
                        arg_oldvalue, arg_value = arg_value.split('|', 1)
                else:
                    arg_name = arg

            #print('>> got arg %s, %s, %s' % (arg_name, arg_rrtype, arg_value))
            if arg_name is not None:
                try:
                    self._name = dns.name.from_text(arg_name)
                    self._valid = True
                except dns.exception.SyntaxError as e:
                    pass

            if arg_server is not None:
                try:
                    self._server = dns.name.from_text(arg_server)
                    self._valid = True
                except dns.exception.SyntaxError as e:
                    pass

            if arg_rrtype is not None:
                try:
                    self._rrtype = dns.rdatatype.from_text(arg_rrtype)
                except dns.exception.SyntaxError as e:
                    self._valid = False
            else:
                self._rrtype = dns.rdatatype.from_text('A')
            if arg_classtype is None:
                arg_classtype = 'IN'

            self._classtype = arg_classtype
            self._value = arg_value
            self._oldvalue = arg_oldvalue

        @property
        def valid(self):
            return self._valid

        @property
        def rrtype(self):
            if self._rrtype is None:
                return None
            return dns.rdatatype.to_text(self._rrtype)

        @property
        def ttl(self):
            return self._ttl

        @property
        def name(self):
            return self._name.to_text()

        @property
        def has_server(self):
            return True if self._server is not None else False

        @property
        def server(self):
            return self._server.to_text()

        @property
        def raw(self):
            return '%s %s %s %s=%s' % (self._name.to_text(), self._classtype, self.rrtype, self._oldvalue, self._value)

        @property
        def value(self):
            if isinstance(self._value, dict):
                values = []
                for (k, v) in self._value.items():
                    values.append(str(v))
            elif isinstance(self._value, list):
                values = self._value
            else:
                values = [ self._value ]
            return ' '.join(values)

        @property
        def has_old_value(self):
            return True if self._oldvalue is not None else False

        def __str__(self):
            if self._rrtype:
                return self.name + ' ' + self.value + '/' + self.rrtype
            else:
                return self.name + ' ' + self.value

        def _get_item(self, possible_keys, default_value=None, index=None, old=False):
            if old:
                return self._get_item_impl(self._oldvalue, possible_keys, default_value, index)
            else:
                return self._get_item_impl(self._value, possible_keys, default_value, index)

        def _get_item_impl(self, var, possible_keys, default_value=None, index=None):
            target_type = None if default_value is None else type(default_value)
            if isinstance(var, dict):
                if isinstance(possible_keys, list):
                    for k in possible_keys:
                        if k in var:
                            return target_type(var[k]) if target_type is not None else var[k]
                    return default_value
                else:
                    if possible_keys in var:
                        return target_type(var[possible_keys]) if target_type is not None else var[possible_keys]
                    return default_value
            elif isinstance(var, list):
                if index is None:
                    return default_value
                else:
                    if index < len(var):
                        return target_type(var[index]) if target_type is not None else var[index]
                    else:
                        return default_value
            else:
                if index is not None and index == 0:
                    return target_type(var) if target_type is not None else var
                else:
                    return default_value

        def to_payload(self, old=False):
            if self._rrtype is None:
                return None
            elif self._rrtype == dns.rdatatype.A or self._rrtype == dns.rdatatype.AAAA:
                addr = self._get_item(['addr', 'host', 'address'], None, index=0, old=old)
                return '%s' % (addr) if addr is not None else None
            elif self._rrtype == dns.rdatatype.MX:
                addr = self._get_item(['addr', 'host', 'address'], None, index=0, old=old)
                priority = self._get_item(['priority', 'prio'], 10, old=old)
                return '%i %s' % (priority, addr) if addr is not None else None
            elif self._rrtype == dns.rdatatype.PTR:
                addr = self._get_item(['addr', 'host', 'address'], None, index=0, old=old)
                return '%s' % (addr) if addr is not None else None
            elif self._rrtype == dns.rdatatype.CNAME:
                addr = self._get_item(['addr', 'host', 'address'], None, index=0, old=old)
                return '%s' % (addr) if addr is not None else None
            elif self._rrtype == dns.rdatatype.NS:
                addr = self._get_item(['addr', 'host', 'address'], None, index=0, old=old)
                return '%s' % (addr) if addr is not None else None
            elif self._rrtype == dns.rdatatype.TXT:
                text = self._get_item(['txt', 'text'], None, index=0, old=old)
                return '"%s"' % (text) if text is not None else None
            elif self._rrtype == dns.rdatatype.SOA:
                mname = self._get_item(['master', 'mname'], 'master.%s' % self.name, index=0, old=old)
                rname = self._get_item(['admin', 'rname'], 'hostmaster.%s' % self.name, index=1, old=old)
                serial = self._get_item(['serial', 'sn'], 0, index=2, old=old)
                refresh = self._get_item(['refresh', 'ref'], 86400, index=3, old=old)
                retry = self._get_item(['retry', 'ret'], 900, index=4, old=old)
                expire = self._get_item(['expire', 'ex'], 86400, index=5, old=old)
                minimum = self._get_item(['minimum', 'min'], 3600, index=6, old=old)
                return '%s %s (%i %i %i %i %i)' % (mname, rname, serial, refresh, retry, expire, minimum)
            else:
                raise Exception('not implmented')

    @staticmethod
    def _split_args(args):
        ok = True
        ret = []
        for arg in args:
            item = dns_update_app.arg_data(arg)
            if not item.valid:
                sys.stderr.write("Invalid syntax for DNS record \"%s\".\n" % (arg))
                ok = False
            else:
                ret.append( item )
        if ok:
            return ret
        else:
            return None


    def _get_update_object(self, name):
        if name in self._updates:
            ret = self._updates[name]
        else:
            ret = None
            try:
                #print('name=%s' % name)
                Origin, dummy = arsoft.dnsutils.get_dns_zone_for_name(name, dnsserver=self.server, timeout=self.timeout)
                if Origin is not None:
                    for (update_name, update) in self._updates.items():
                        if update.origin == Origin:
                            return update
                    ret = dns.update.Update(Origin)
                    if self.keyfile:
                        if not arsoft.dnsutils.use_key_file(ret, self.keyfile, arsoft.dnsutils.KeyFileFormat.Automatic):
                            sys.stderr.write("Unable to load key file %s\n" % (self.keyfile))
                            ret = None
                    if ret:
                        self._updates[name] = ret
            except dns.resolver.NoNameservers as e:
                sys.stderr.write("No nameserver found for %s\n" % (name))
                ret = None
            except dns.exception.Timeout as e:
                sys.stderr.write("Unable to get DNS zone for %s after %s seconds\n" % (name, self.timeout))
                ret = None
        return ret

    def _add_record(self, args):
        if args is None:
            return False
        ret = True
        for arg in args:
            update = self._get_update_object(arg.name)
            if update is None:
                ret = False
            else:
                payload = arg.to_payload(old=False)
                if payload is None:
                    sys.stderr.write("Unable to convert %s to DNS payload\n" % (arg.raw))
                    continue

                if arg.has_old_value:
                    sys.stderr.write("WARNING: given record has an old value. Use update instead of add operation to use the old value.\n")

                try:
                    update.add(arg.name, arg.ttl, arg.rrtype, payload)
                except dns.exception.SyntaxError as e:
                    sys.stderr.write("Syntax error for adding %s record %s: %s\n" % (arg.rrtype, arg.name, payload))
                    ret = False
        return ret

    def _delete_record(self, args):
        if args is None:
            return False
        ret = True
        for arg in args:
            update = self._get_update_object(arg.name)
            if update is None:
                ret = False
            else:
                payload = arg.to_payload(old=False)
                if payload is None:
                    sys.stderr.write("Unable to convert %s to DNS payload\n" % (arg.raw))
                    continue

                try:
                    if payload is None:
                        update.delete(arg.name, arg.rrtype)
                    else:
                        update.delete(arg.name, arg.rrtype, payload)
                except dns.exception.SyntaxError as e:
                    sys.stderr.write("Syntax error for delete %s record %s: %s\n" % (arg.rrtype, arg.name, payload))
                    ret = False
        return ret

    def _update_record(self, args):
        if args is None:
            return False
        ret = True
        for arg in args:
            update = self._get_update_object(arg.name)
            if update is None:
                ret = False
            else:
                payload = arg.to_payload(old=False)
                if payload is None:
                    sys.stderr.write("Unable to convert %s to DNS payload\n" % (arg.raw))
                    continue

                if arg.has_old_value:
                    old_payload = arg.to_payload(old=True)
                    delete_ok = False
                    try:
                        update.delete(arg.name, arg.rrtype, old_payload)
                        delete_ok = True
                    except dns.exception.SyntaxError as e:
                        sys.stderr.write("Syntax error for delete %s record %s: %s\n" % (arg.rrtype, arg.name, old_payload))
                        ret = False
                    if delete_ok:
                        try:
                            update.add(arg.name, arg.ttl, arg.rrtype, payload)
                        except dns.exception.SyntaxError as e:
                            sys.stderr.write("Syntax error for adding %s record %s: %s\n" % (arg.rrtype, arg.name, payload))
                            ret = False
                else:
                    try:
                        update.replace(arg.name, arg.ttl, arg.rrtype, payload)
                    except dns.exception.SyntaxError as e:
                        sys.stderr.write("Syntax error for adding %s record %s: %s\n" % (arg.rrtype, arg.name, payload))
                        ret = False
        return ret

    def _update_host(self, args):
        if args is None:
            return False
        ret = True
        for arg in args:
            if isinstance(payload, list):
                addr_list = payload
            else:
                addr_list = payload.split(',')

            name = dns.name.from_text(name)
            update = self._get_update_object(host)
            if update is None:
                ret = False
            else:
                update.delete(name, self.rrtype)
                for addr in addr_list:
                    update.add(name, self.ttl, self.rrtype, addr)
                    if (self.rrtype == 'A' or self.rrtype == 'AAAA') and not self.no_reverse:
                        # delete reverse addr and re-add it afterwards
                        revaddrname = dns.reversename.from_address(addr)
                        Origin, dummy = arsoft.dnsutils.get_dns_zone_for_name(revaddrname)
                        #print(Origin, dummy)
                        rev_update = self._get_update_object(revaddrname)
                        if rev_update:
                            rev_update.delete(revaddrname, 'PTR')
                            rev_update.add(revaddrname, self.ttl, 'PTR', addr)
        return ret

    def _import_host(self, args):
        if args is None:
            return False
        anotherserver = None
        hosts_to_import = []

        for arg in args:
            if arg.has_server:
                anotherserver = arg.server
            else:
                hosts_to_import.append( arg )

        if anotherserver is None:
            sys.stderr.write("No DNS server to query specified.\n")
            ret = False
        else:
            ipv6 = True if self.rrtype == 'AAAA' else False
            ret = True
            for arg in hosts_to_import:
                host = arg.name
                rrtype = arg.rrtype

                target_hostaddr = None
                try:
                    target_hostaddr = arsoft.dnsutils.get_dns_host_record(host, ipv6=ipv6, dnsserver=self.server, timeout=self.timeout)
                except dns.resolver.NoAnswer as e:
                    sys.stderr.write("Failed to retrieve host record %s from target DNS server %s - no answer.\n" % (host, self.server))
                except dns.resolver.NXDOMAIN as e:
                    sys.stderr.write("Failed to retrieve host record %s from target DNS server %s - domain does not exist.\n" % (host, self.server))
                except dns.exception.Timeout as e:
                    sys.stderr.write("Failed to retrieve host record %s from target DNS server %s - timeout.\n" % (host, self.server))

                if target_hostaddr is None:
                    ret = False
                    sys.stderr.write("Failed to retrieve host record %s from target DNS server %s.\n" % (host, self.server))
                    continue

                anotherserver_hostaddr = None
                try:
                    anotherserver_hostaddr = arsoft.dnsutils.get_dns_host_record(host, ipv6=ipv6, dnsserver=anotherserver, timeout=self.timeout)
                except dns.resolver.NoAnswer as e:
                    sys.stderr.write("Failed to retrieve host record %s from remote DNS server %s - no answer.\n" % (host, anotherserver))
                except dns.resolver.NXDOMAIN as e:
                    sys.stderr.write("Failed to retrieve host record %s from remote DNS server %s - domain does not exist.\n" % (host, anotherserver))
                except dns.exception.Timeout as e:
                    sys.stderr.write("Failed to retrieve host record %s from remote DNS server %s - timeout.\n" % (host, anotherserver))

                if anotherserver_hostaddr is None:
                    ret = False
                    sys.stderr.write("Failed to retrieve host record %s from remote DNS server %s.\n" % (host, anotherserver))
                    continue

                if not _is_hostaddr_equal(target_hostaddr, anotherserver_hostaddr):
                    if self.verbose:
                        print("Update host record %s from %s to %s." % (host, target_hostaddr, anotherserver_hostaddr))
                    update_tuple = (host, anotherserver_hostaddr)
                    if not self._update_host( [ update_tuple ] ):
                        sys.stderr.write("Failed to update host record %s on target DNS server\n" % (host, self.server))
                        ret = False
                else:
                    if self.verbose:
                        print("Host record %s up-to-date %s<>%s." % (host, target_hostaddr, anotherserver_hostaddr))
        return ret

    def _dump_zone(self, zone):
        level = 0
        print("Zone origin: %s" % zone.origin)
        for name, node in list(zone.nodes.items()):
            level = 1
            indent = ' ' * (2*level)
            rdatasets = node.rdatasets
            print(indent + "node %s" % name)
            for rdataset in rdatasets:
                level = 2
                indent = ' ' * (2*level)
                print(indent + "rdataset string representation: %s" % str(rdataset))
                print(indent + "rdataset rdclass: %s" % dns.rdataclass.to_text(rdataset.rdclass))
                print(indent + "rdataset rdtype: %s" % dns.rdatatype.to_text(rdataset.rdtype))
                print(indent + "rdataset ttl: %i" % rdataset.ttl)
                for rdata in rdataset:
                    level = 3
                    indent = ' ' * (2*level)
                    print(indent + "rdata string representation: %s" % str(rdata))
                    print(indent + "** %s-specific rdata **" % dns.rdatatype.to_text(rdataset.rdtype) )
                    if rdataset.rdtype == dns.rdatatype.SOA:
                        print(indent + "expire: %i" % rdata.expire)
                        print(indent + "minimum: %i" % rdata.minimum)
                        print(indent + "mname: %s" % rdata.mname)
                        print(indent + "refresh: %i" % rdata.refresh)
                        print(indent + "retry: %i" % rdata.retry)
                        print(indent + "rname: %s" % rdata.rname)
                        print(indent + "serial: %s" % rdata.serial)
                    elif rdataset.rdtype == dns.rdatatype.MX:
                        print(indent + "exchange: %s" % rdata.exchange)
                        print(indent + "preference: %i" % rdata.preference)
                    elif rdataset.rdtype == dns.rdatatype.NS:
                        print(indent + "target: %s" % rdata.target)
                    elif rdataset.rdtype == dns.rdatatype.CNAME:
                        print(indent + "target: %s" % rdata.target)
                    elif rdataset.rdtype == dns.rdatatype.A:
                        print(indent + "address: %s" % rdata.address)
                    elif rdataset.rdtype == dns.rdatatype.AAAA:
                        print(indent + "address: %s" % rdata.address)
                    elif rdataset.rdtype == dns.rdatatype.TXT:
                        print(indent + "text: %s" % str(rdata.strings))
                    elif rdataset.rdtype == dns.rdatatype.SRV:
                        print(indent + "port: %i" % rdata.port)
                        print(indent + "priority: %i" % rdata.priority)
                        print(indent + "target: %s" % rdata.target)
                        print(indent + "weight: %i" % rdata.weight)
                    else:
                        print(indent + "data: %s" % str(rdata))

    def _update_file(self, args, origin=None):
        if args is None:
            return False
        ret = True
        for f in args:
            zone = None
            try:
                zone = dns.zone.from_file(f, origin=origin)
            except IOError as e:
                ret = False
                sys.stderr.write("Failed to read from zone file %s. Error %s\n" % (f, str(e)))
            except dns.zone.NoSOA as e:
                ret = False
                sys.stderr.write("Zone file %s does not contain a SOA record.\n" % (f))
            except dns.zone.NoNS as e:
                ret = False
                sys.stderr.write("Zone file %s does not contain a NS record for the SOA record.\n" % (f))
            except dns.exception.SyntaxError as e:
                ret = False
                sys.stderr.write("Zone file %s contains syntax error(s). %s\n" % (f, str(e)))
            if zone is None:
                continue
            if self.verbose:
                self._dump_zone(zone)
            for name, node in list(zone.nodes.items()):
                level = 1
                indent = ' ' * (2*level)
                rdatasets = node.rdatasets
                if self.verbose:
                    print(indent + "node %s" % name)
                for rdataset in rdatasets:
                    if rdataset.rdtype == dns.rdatatype.SOA:
                        # skip SOA
                        continue
                    elif rdataset.rdtype == dns.rdatatype.NS:
                        is_loopback_ns = False
                        for rdata in rdataset:
                            if str(rdata.target) == '127.0.0.1':
                                is_loopback_ns = True
                        if is_loopback_ns:
                            continue

                    full_node = dns.name.from_text(str(name), zone.origin)
                    update = self._get_update_object(full_node)
                    update.delete(full_node, rdataset)
                    update.add(full_node, rdataset)

        return ret

    def _lookup_hosts(self, args):

        ret = True
        dnsserver = self.server
        hosts_to_lookup = []
        for arg in args:
            if arg.has_server:
                dnsserver = arg.server
            else:
                hosts_to_lookup.append( arg )

        for arg in hosts_to_lookup:
            host = arg.name
            rrtype = arg.rrtype

            hostaddr = None
            try:
                resolver = arsoft.dnsutils._get_resolver(dnsserver, timeout=self.timeout)
                if resolver:
                    answers = resolver.query(arg.name, arg.rrtype)
                    for rdata in answers:
                        print(rdata)
                else:
                    ret = False
            except dns.resolver.NoAnswer as e:
                sys.stderr.write("Failed to retrieve %s record %s from DNS server %s - no answer.\n" % (arg.rrtype, arg.name, dnsserver))
                ret = False
            except dns.resolver.NXDOMAIN as e:
                sys.stderr.write("Failed to retrieve %s record %s from DNS server %s - domain does not exist.\n" % (arg.rrtype, arg.name, dnsserver))
                ret = False
            except dns.exception.Timeout as e:
                sys.stderr.write("Failed to retrieve %s record %s from DNS server %s - timeout.\n" % (arg.rrtype, arg.name, dnsserver))
                ret = False
        return ret

    def main(self):
        #=============================================================================================
        # process command line
        #=============================================================================================
        parser = argparse.ArgumentParser(description='add/update/delete the DNS information',
                                         formatter_class=argparse.RawDescriptionHelpFormatter,
                                         epilog=dns_update_app.SYNTAX_HELP)
        parser.add_argument('-v', '--verbose', dest='verbose', action='store_true', help='enable verbose output of this script.')
        parser.add_argument('--noop', dest='noop', action='store_true', help='no not actual update anything, just show what would be done.')
        parser.add_argument('--no-reverse', dest='no_reverse', action='store_true', help='no not automatically update PTR records for A/AAAA record.')
        parser.add_argument('--available', dest='available', action='store_true', help='checks if EFI is available on this machine.')
        parser.add_argument('--server', dest='server', help='name of the DNS server for updates')
        parser.add_argument('--rrtype', dest='rrtype', default=self.DEFAULT_RRTYPE, help='specify the RR type for the next operation')
        parser.add_argument('--ttl', dest='ttl', default=self.DEFAULT_TTL, help='specify the TTL for the records')
        parser.add_argument('-k', '--key', dest='keyfile', default=self.DEFAULT_KEYFILE, help='key to use for the update')
        parser.add_argument('-g', '--gssapi', dest='gssapi', action='store_true', help='use GSSAPI for authentication')
        parser.add_argument('-t', '--timeout', dest='timeout', default=self.DEFAULT_TIMEOUT, help='set the timeout for DNS queries and updates')

        parser.add_argument('-l', '--lookup', dest='lookup', nargs='+', help='look up the given DNS record')
        parser.add_argument('-a', '--add', dest='add', nargs='+', help='adds the given DNS record; name value')
        parser.add_argument('-d', '--delete', dest='delete', nargs='+', help='deletes the specified DNS record')
        parser.add_argument('-u', '--update', dest='update', nargs='+', help='updates the specified DNS record')
        parser.add_argument('--update-file', dest='update_file', nargs='+', help='load DNS records from the given files and update them.')
        parser.add_argument('--update-host', dest='update_host', nargs='+', help='updates the given host for the specified address.')
        parser.add_argument('--import-host', dest='import_host', nargs='+', help='import the result from the specified DNS server and update the local DNS server.')

        args = parser.parse_args()

        self.verbose = args.verbose
        self.noop = args.noop
        self.no_reverse = args.no_reverse
        self.ttl = args.ttl
        self.rrtype = args.rrtype
        if args.server is None:
            self.server = arsoft.dnsutils.get_default_dnsserver()
        else:
            self.server = args.server
        self.keyfile = args.keyfile
        self.timeout = args.timeout
        self.gssapi = args.gssapi

        perform_update = True

        if args.add:
            if not self._add_record(dns_update_app._split_args(args.add)):
                perform_update = False
        if args.delete:
            if not self._delete_record(dns_update_app._split_args(args.delete)):
                perform_update = False
        if args.update:
            if not self._update_record(dns_update_app._split_args(args.update)):
                perform_update = False

        if args.update_host:
            if not self._update_host(dns_update_app._split_args(args.update_host)):
                perform_update = False

        if args.update_file:
            if not self._update_file(args.update_file):
                perform_update = False

        if args.import_host:
            if not self._import_host(dns_update_app._split_args(args.import_host)):
                perform_update = False

        if args.lookup:
            if not self._lookup_hosts(dns_update_app._split_args(args.lookup)):
                perform_update = False

        if perform_update:
            if len(self._updates) == 0:
                if self.verbose:
                    print('Nothing to do.')
                ret = 0
            else:
                ret = 0
                for (host, update) in self._updates.items():
                    if self.verbose or self.noop:
                        print('update %s with:\n%s\n' % (host, update))
                    if not self.noop:
                        try:
                            response = dns.query.tcp(update, args.server)
                            if response:
                                if response.rcode() != dns.rcode.NOERROR:
                                    sys.stderr.write("Update %s failed with error %s\n" % (host, dns.rcode.to_text(response.rcode())) )
                                    ret = 1
                                else:
                                    if self.verbose:
                                        print('Update %s successful\n' % (host))
                            else:
                                sys.stderr.write("No response for update of %s\n" % (host) )
                                ret = 1
                        except socket.error as e:
                            sys.stderr.write("Network error on update %s: %s\n" % (host, str(e)) )
                            ret = 1

        else:
            ret = 1
        return ret

if __name__ == "__main__":
    app =  dns_update_app()
    sys.exit(app.main())

#!/usr/bin/python3
# -*- coding: utf-8 -*-
# kate: space-indent on; indent-width 4; mixedindent off; indent-mode python;

import os, sys
import argparse
import datetime
import subprocess

from arsoft.eurosport.Config import Config
from arsoft.eurosport.Login import Login
from arsoft.eurosport.Program import Program
from arsoft.eurosport.Stream import StreamDownloader
from arsoft.eurosport.Channel import Channel
from sys import stdin
import time


class eurosport_stream_app(object):

    QUALITY_NAMES = {
        2: ['low', ('high', 'best') ],
        3: ['low', 'medium', ('high', 'best') ],
        4: ['low', 'medium', 'high', ('highest', 'best') ],
        5: ['lowest', 'low', 'medium', 'high', ('highest', 'best') ],
        6: ['lowest', 'low', 'medium-low', 'medium', 'high', ('highest', 'best') ],
        7: ['lowest', 'low', 'medium-low', 'medium', 'medium-high', 'high', ('highest', 'best') ],
        8: ['lowest', 'lower', 'low', 'medium-low', 'medium', 'medium', 'high', ('highest', 'best') ],
        }

    def log(self, msg):
        if self._verbose:
            print(msg)

    def __init__(self):
        self._verbose = False
        self._script_name = os.path.basename(__file__)
        self._config = None

    def main(self, argv=None):
        #=============================================================================================
        # process command line
        #=============================================================================================
        default_config_file = os.path.expanduser('~/.config/eurosport-stream')
        parser = argparse.ArgumentParser(description='send e-mail')
        parser.add_argument('-v', '--verbose', dest='verbose', action='store_true', help='enable verbose output of this script.')
        parser.add_argument('-d', '--debug', dest='debug', action='store_true', help='enable debug mode.')
        parser.add_argument('--config', dest='config_file', default=default_config_file, help='Specify config file')
        parser.add_argument('--email', dest='email', help='Eurosport login account name')
        parser.add_argument('--password', dest='password', help='Eurosport password')
        parser.add_argument('--lang', dest='language', help='Language of the stream; e.g. de, en, fr')
        parser.add_argument('--geo', dest='geo', help='Geo-location code')
        parser.add_argument('--devtype', dest='devtype', help='Overwrite device type')
        parser.add_argument('--product', dest='productid', help='Overwrite product id')
        parser.add_argument('-s', '--schedule', dest='show_schedule', action='store_true', help='show the schedule of the selected channel.')
        parser.add_argument('channel', default='list', nargs='?', help='select channel for playback; if not specified list of available streams is displayed')

        ret = 0

        args = parser.parse_args()
        self._verbose = args.verbose
        self._debug = args.debug
        if self._debug:
            import json

        save_config = False
        self._config = Config(filename=args.config_file)
        if not self._config.email and args.email is not None:
            self._config.email = args.email
            save_config = True
        if not self._config.password and args.password is not None:
            self._config.password = args.password
            save_config = True

        if args.geo is not None:
            self._config.geo = args.geo
            save_config = True
        if args.language is not None:
            self._config.language = args.language
            save_config = True
        if args.devtype is not None:
            self._config.devtype = args.devtype
            save_config = True
        if args.productid is not None:
            self._config.productid = args.productid
            save_config = True

        if save_config:
            #print('save config')
            self._config.save(filename=args.config_file)

        options = {}
        options['debug'] = self._debug
        if self._config.geo is not None:
            options['geoloc'] = self._config.geo
        if self._config.country is not None:
            options['country'] = self._config.country
        if self._config.language is not None:
            options['language'] = self._config.language
        if self._config.devtype is not None:
            options['devtype'] = self._config.devtype
        if self._config.productid is not None:
            options['productid'] = self._config.productid

        Login.configure(self._config.email, self._config.password, options)
        ret = 0

        channels = None
        try:
            channels = Program.get_channel_list()
        except Login.IsNotConfigured:
            sys.stderr.write('Missing login credentials.\n')
            ret = 1
        except Login.InvalidLoginData as e:
            sys.stderr.write('Invalid login credentials: %s.\n' % e)
            ret = 1
        except Login.NetworkError:
            sys.stderr.write('Network error. Unable to login to Eurosport.\n')
            ret = 2
        except Login.InvalidContext:
            sys.stderr.write('Invalid context.\n')
            ret = 4
        except Login.LoginIncorrect:
            sys.stderr.write('Incorrect login credentials.\n')
            ret = 5

        if channels:
            if args.channel == 'list' or args.channel == '*':
                for i, ch in enumerate(channels):
                    print('#%i: %s' % (i+1, ch.name))
                    if self._verbose:
                        print('  Url: %s' % (ch.stream_url))
                    if self._debug:
                        f = open('/tmp/channel_%i' % i, 'w')
                        f.write(json.dumps(ch.data, indent='  '))
                        f.close()

                    current_show = ch.find_current_show()
                    if current_show:
                        if self._debug:
                            f = open('/tmp/channel_%i_show' % i, 'w')
                            f.write(json.dumps(current_show.data, indent='  '))
                            f.close()
                        print('  Current show: %s from %s to %s' % (current_show.title, current_show.starttime, current_show.endtime))

                    if args.show_schedule:
                        print('  Schedule:')
                        for schedule in ch.schedules:
                            if schedule.is_now:
                                print('  * %s %s: %s' % (schedule.starttime, schedule.duration_human, schedule.title))
                            else:
                                print('    %s %s: %s' % (schedule.starttime, schedule.duration_human, schedule.title))

                    streams = None
                    try:
                        ch.download_playlist()
                        streams = sorted(ch.streams, key=lambda stream: stream.bandwidth)
                    except Channel.InvalidData:
                        pass
                    except Channel.NoLiveStream:
                        pass
                    except Channel.NoCatchupStream:
                        pass

                    if streams:
                        print('  Streams:')
                        for stream_no, stream in enumerate(streams):
                            print('    %i: %i bits/sec' % (stream_no + 1, stream.bandwidth))
            else:
                channel = args.channel
                timeoffset = 0
                if '-' in args.channel:
                    (channel, timeoffset) = channel.split('-', 1)
                if '/' in channel:
                    (channel_no, quality) = channel.split('/', 1)
                elif '@' in channel:
                    (channel_no, quality) = channel.split('@', 1)
                else:
                    channel_no = channel
                    quality = self._config.quality
                try:
                    channel_no = int(channel_no)
                except ValueError:
                    channel_no = -1
                try:
                    if quality is not None:
                        quality = int(quality)
                except ValueError:
                    pass

                ch = None
                try:
                    if channel_no >= 0:
                        ch = channels[channel_no]
                except IndexError:
                    pass

                if ch:

                    if args.show_schedule:
                        print('Schedule:')
                        for schedule in ch.schedules:
                            if schedule.is_now:
                                print('* %s %s: %s' % (schedule.starttime, schedule.duration_human, schedule.title))
                            else:
                                print('  %s %s: %s' % (schedule.starttime, schedule.duration_human, schedule.title))
                    else:
                        try:
                            ch.download_playlist(timeoffset=timeoffset)
                            if quality is not None:
                                if isinstance(quality, int) and quality < 100:
                                    quality_options = ch.get_available_quality_options()
                                    if quality > len(quality_options):
                                        sys.stderr.write('Invalid stream index %i (max %i)\n' %(quality, len(quality_options)))
                                    else:
                                        quality = quality_options[quality]
                                elif isinstance(quality, str):
                                    if quality == 'best':
                                        quality = None
                                    else:
                                        quality_options = ch.get_available_quality_options()
                                        num_streams = len(quality_options)
                                        self.log('got %i streams' % num_streams)
                                        if num_streams in self.QUALITY_NAMES:
                                            found = False
                                            self.log('possible qualtiy names %s, requested %s' % (self.QUALITY_NAMES[num_streams], quality))
                                            for index, e in enumerate(self.QUALITY_NAMES[num_streams]):
                                                self.log("got %i, %s" % (index, e))
                                                if isinstance(e, str) and e == quality:
                                                    self.log('Found quality %s at index %i' % (quality, index))
                                                    quality = index
                                                    found = True
                                                    break
                                                elif hasattr(e, '__iter__') and quality in e:
                                                    self.log('Found quality %s at index %i' % (quality, index))
                                                    quality = index
                                                    found = True
                                                    break
                                            quality = quality_options[quality] if found else None
                            ch.set_quality(quality)
                        except Channel.InvalidData:
                            ch = None
                        except Channel.NoLiveStream:
                            ch = None
                        except Channel.NoCatchupStream:
                            ch = None

                        if ch:
                            sd = StreamDownloader(ch.active_stream)

                            vlc_args = ['vlc', '-']
                            p = subprocess.Popen(vlc_args, stdout=sys.stderr, stderr=sys.stderr, stdin=subprocess.PIPE, shell=False)
                            if p:
                                while 1:
                                    try:
                                        p.stdin.write(sd.get_next_part())
                                    except StreamDownloader.NoDataAvailable:
                                        time.sleep(1)
                                        continue
                                    except KeyboardInterrupt:
                                        sd.stop()
                                        break
                                    except BrokenPipeError:
                                        sd.stop()
                                        break
                                p.terminate()
                else:
                    sys.stderr.write('Unable to find channel %s\n' %channel_no)
                    ret = 2

        return ret

if __name__ == "__main__":
    app = eurosport_stream_app()
    sys.exit(app.main(sys.argv))

#!/usr/bin/python3
# -*- coding: utf-8 -*-
# kate: space-indent off; indent-width 4; mixedindent off; indent-mode python;

from arsoft.netconfig import *
from logging import debug, info, exception, error, warning, handlers
import logging
import os
import argparse

class PXEConfig(object):
	m_netconfig = None
	m_tftpdir = None
	m_dhcp_conf_dir = None
	m_dhcpd_conf = None
	m_pxeclient_conf = None
	m_pxedir = None
	m_graphics_conf = None
	m_environ = {'confdir':'/etc/dhcp',
					'rundir':'/var/run',
				}

	m_graphics_conf_content = "MENU COLOR TABMSG 37;40      #80ffffff #00000000\n\
MENU COLOR HOTSEL 30;47      #40000000 #20ffffff\n\
MENU COLOR SEL 30;47      #40000000 #20ffffff\n\
MENU COLOR SCROLLBAR 30;47      #40000000 #20ffffff\n\
MENU MASTER PASSWD pass\n\
MENU PASSPROMPT Enter Password:\n\
MENU WIDTH 78\n\
MENU MARGIN 0\n\
MENU ENDROW 20\n\
MENU ROWS 10\n\
MENU TABMSGROW 18\n\
MENU STARTROW 8\n\
MENU CMDLINEROW 18\n\
MENU TIMEOUTROW 18\n\
MENU HSHIFT 0\n\
MENU VSHIFT 11\n\
NOESCAPE 1\n\
ALLOWOPTIONS 0\n\
"

	def __init__(self, netconfig=None, tftpdir=None, dhcpdir=None):
		if netconfig != None:
			self.m_netconfig = netconfig
		else:
			self.m_netconfig = Netconfig()
			
		# use default if no values are given
		if tftpdir is None:
			tftpdir = '/var/lib/tftproot'
		if dhcpdir is None:
			dhcpdir = '/etc/dhcp'

		self.m_dhcp_conf_dir = dhcpdir
		self.m_dhcpd_conf = self.m_dhcp_conf_dir + '/dhcpd.conf'
		self.m_pxeclient_conf = self.m_dhcp_conf_dir + '/pxeclient.conf'
		self.m_tftpdir = tftpdir
		self.m_pxedir = self.m_tftpdir + '/pxelinux.cfg'
		self.m_graphics_conf = self.m_pxedir + '/graphics.conf'
		self.m_netconfig.addEnvironment(self.m_environ)
		
	def _pxepath(self, s):
		ret = s.replace(self.m_tftpdir,'')
		if ret[0] == '/':
			return ret[1:]
		else:
			return ret

	def _unquote(self, string):
		l = len(string)
		if (string[0] == '"' or string[0] == '\'') and (string[l-1] == '"' or string[l-1] == '\''):
			return string[1:l - 1]
		else:
			return string

	def update_pxe_clients(self, pxeclient_conf=None):
		ret = False
		if pxeclient_conf is None:
			pxeclient_conf = self.m_pxeclient_conf
		try:
			debug("create " + pxeclient_conf)

			if pxeclient_conf == '-':
				f = sys.stdout
			else:
				p = os.path.dirname(pxeclient_conf)
				createpath(p)
				f = open(pxeclient_conf,'w')
				
			f.write("#\n")
			f.write("# AR Soft Network Configuration\n")
			f.write("#\n")
			f.write("# Automatically generated configuration file for DHCPv3\n")
			f.write("#\n")

			for node in self.m_netconfig.getNodes():
				for addr in node.address:
					section_host=node.name + '-' + addr.raw()
					f.write('# computer ' + node.dn + ' (arch ' + node.arch + ')\n')
					f.write('host ' + section_host + ' {\n')
					f.write('    option pxelinux.configfile = \"pxelinux.cfg/' + node.name + '.conf";\n')
					f.write('    option host-name "' + node.name + '";\n')
					f.write('    filename "/pxelinux.0";\n')
					f.write('    hardware ethernet ' + str(addr) + ';\n')
					f.write('}\n')

			f.write("#\n")
			f.write("# EOF\n")
			f.write("#\n")
			f.close()
			ret = True
		except IOError as e:
			error("error creating " + pxeclient_conf + ":" + str(e))
			ret = False
		
	def patch_dhcp_conf(self, dhcpd_conf=None, pxeclient_conf=None):
		if dhcpd_conf is None:
			dhcpd_conf = self.m_dhcpd_conf
		if pxeclient_conf is None:
			pxeclient_conf = self.m_pxeclient_conf
		found = False
		try:
			debug("patch " + dhcpd_conf)

			p = os.path.dirname(dhcpd_conf)
			createpath(p)

			f = open(dhcpd_conf,'r')
			for line in f:
				if line.endswith(';\n'):
					e = line.replace(';\n','').split(' ')
					if e[0] == 'include':
						f = self._unquote(e[1])
						if f == pxeclient_conf or f == os.path.abspath(pxeclient_conf):
							found = True
			f.close()
		except IOError as e:
			error("error patching " + dhcpd_conf + ":" + str(e))
			found = False
			
		if found == False:
			try:
				debug("create " + dhcpd_conf)

				p = os.path.dirname(dhcpd_conf)
				createpath(p)
			
				f = open(dhcpd_conf,'a')
				f.write('include "' + os.path.abspath(pxeclient_conf) + '";\n')
				f.close()
			except IOError as e:
				error("error creating " + self.m_dhcpd_conf + ":" + str(e))
				ret = False
		return ret

	def create_boot_menu(self, tftpdir=None):
		if tftpdir is None:
			tftpdir = self.m_tftpdir

		pxedir = tftpdir + '/pxelinux.cfg'
		graphics_conf = pxedir + '/graphics.conf'

		p = os.path.dirname(graphics_conf)
		createpath(p)

		try:
			f = open(graphics_conf, 'w')
			f.write(self.m_graphics_conf_content)
			f.close()
			ret = True
		except:
			ret = False
			pass

		if ret:
			menus = self.m_netconfig.getBootMenus();
			if menus is None:
				debug('no boot menus available')
			else:
				debug('create boot menu for default node')
				self._create_boot_menu(None, menus)
				for node in self.m_netconfig.getNodes():
					debug('create boot menu for node ' + node.name)
					self._create_boot_menu(node, menus)
		return ret

	def _create_boot_menu(self, node, menuitem, menufile=None):
		if menufile is None:
			if node is not None:
				menufile = self.m_pxedir + '/' + node.name + '.conf'
				for a in node.address:
					hwaddrfile = self.m_pxedir + '/' + a.toPXELinux()
					if os.path.exists(hwaddrfile):
						os.remove(hwaddrfile)
					os.symlink(node.name + '.conf', hwaddrfile)
			else:
				menufile = self.m_pxedir + '/default'
		if node is not None:
			debug('_create_boot_menu node=' + node.name + ' menufile=' + menufile + ' title=' + menuitem.title)
		else:
			debug('_create_boot_menu node=None menufile=' + menufile + ' title=' + menuitem.title)
		f = open(menufile, 'w')

		f.write("# AR Soft Network Configuration " + self._pxepath(menufile) + "\n")
		f.write("# " + menuitem.dn + "\n")
		f.write("#\n")
		if node is not None:
			f.write("# Automatically generated menu file for " + node.name + "\n")
		else:
			f.write("# Automatically generated menu file for default node\n")
		f.write("#\n")
		f.write("DEFAULT vesamenu.c32\n")
		f.write("PROMPT 0\n")

		if node is not None:
			f.write("MENU TITLE " + menuitem.title + " on " + node.name + "\n")
		else:
			f.write("MENU TITLE " + menuitem.title + " on default node\n")
		f.write("MENU INCLUDE " + self._pxepath(self.m_graphics_conf) + "\n")
		f.write("MENU AUTOBOOT Starting Local System in # seconds\n")

		if menuitem.position is not None:
			endrow=menuitem.position.top + menuitem.position.height

			f.write("MENU HSHIFT 0\n")
			f.write("MENU WIDTH %i\n" % menuitem.position.width)
			f.write("MENU ROWS %i\n" % menuitem.position.height)
			f.write("MENU MARGIN %i\n" % menuitem.position.left)
			f.write("MENU ENDROW %i\n" % endrow)
			f.write("MENU VSHIFT %i\n" % menuitem.position.top)

		if len(menuitem.background) > 0:
			f.write("MENU BACKGROUND " + menuitem.background + "\n")

		for item in menuitem.childs:
			
			include=True
			if len(item.childs) == 0 and len(item.kernel) == 0 and item.local is None:
				include=False
			if len(item.arch) != 0 and item.arch != None and node != None and node.arch != None and item.arch != node.arch:
				include=False

			if include == True:
				#print 'add menu item ' + item.dn
				f.write('LABEL ' + item.cn + '\n')
				f.write('  MENU LABEL ' + item.title + '\n')

				if node is not None:
					childmenufile = self.m_pxedir + '/' + node.name + '-' + item.cn + '.menu'
				else:
					childmenufile = self.m_pxedir + '/default' + '-' + item.cn + '.menu'
				if len(item.childs) != 0:
					kernel='vesamenu.c32'
					append=self._pxepath(childmenufile) + ' ' + self._pxepath(self.m_graphics_conf)
				else:
					kernel=item.kernel
					append = item.append
					if item.hasFlag('preseed'):
						append = self.appendForPreseed(node, item.getFlag('preseed'), append)
					elif item.hasFlag('autoyast'):
						append = self.appendForAutoYAST(node, item.getFlag('autoyast'), append)
					elif item.hasFlag('kickstart'):
						append = self.appendForKickstart(node, item.getFlag('kickstart'), append)
				if item.timeout >= 0:
					f.write('  TIMEOUT %i\n'%item.timeout)
				if len(kernel) > 0:
					f.write('  KERNEL ' + kernel + '\n')
				if len(append) > 0:
					f.write('  APPEND ' + append + '\n')
				if item.local is not None:
					f.write('  LOCALBOOT ' + item.local + '\n')

				if len(item.childs) != 0:
					self._create_boot_menu(node, item, childmenufile)

		if menuitem.parent is not None:
			if len(menuitem.childs) > 0:
				f.write('MENU SEPARATOR\n')
			f.write('LABEL return\n')
			f.write('  MENU LABEL ^Return to main menu\n')
			f.write('  KERNEL vesamenu.c32\n')
			if menuitem.parent.parent is None:
				if node is not None:
					parentmenufile = self.m_pxedir + '/' + node.name + '.conf'
				else:
					parentmenufile = self.m_pxedir + '/default'
			else:
				if node is not None:
					parentmenufile = self.m_pxedir + '/' + node.name + '-' + menuitem.parent.cn + '.menu'
				else:
					parentmenufile = self.m_pxedir + '/default' + '-' + menuitem.parent.cn + '.menu'
			f.write('  APPEND ' + self._pxepath(self.m_graphics_conf) + ' ' + self._pxepath(parentmenufile) + '\n')

		f.write('#\n')
		f.write('# EOF ' + self._pxepath(menufile) + '\n')
		f.write('#\n')
		f.close()
	def appendForPreseed(self, node, value, append):
		if value is not None:
			item = self.m_netconfig.getPreseed(value)
			if item is not None:
				append += ' preseed/url="' + item.getURL(node) + '" '
				append += item.getAppend(node)
		return append

	def appendForAutoYAST(node, value, append):
		return append

	def appendForKickstart(node, value, append):
		return append

	def dump(self):
		return 0
#        print self.m_cfgfile.toString()


class PXEConfigApp(object):

	def _initLog(self, verbose=False):
		root = logging.getLogger('')
		# allow each log channel to decide which msg to keep and which to ignore
		root.setLevel(logging.DEBUG)
		console = logging.StreamHandler(sys.stderr)
		if verbose:
			level = logging.DEBUG
		else:
			level = logging.WARNING
		console.setLevel(level)
		console.setFormatter(logging.Formatter(
			"%(asctime)s\t%(process)d\t%(threadName)s\t%(levelname)s\t%(message)s",
			datefmt="%Y-%m-%d_%H:%M:%S",
			)
		)
		root.addHandler(console)

		#log:changes every days, 3 files max
		try:
			flog=handlers.TimedRotatingFileHandler('/tmp/pxeconfig.log', "d", 1, 3)
			flog.setLevel(logging.DEBUG)
			formatter = logging.Formatter(
				"%(asctime)s\t%(process)d\t%(threadName)s\t%(levelname)s\t%(message)s",
				datefmt="%Y-%m-%d_%H:%M:%S",
			)
			flog.setFormatter(formatter)
			root.addHandler(flog)
		except IOError as e:
			pass

	def main(self, argv=None):
		if argv is None:
			argv = sys.argv
			
		#=============================================================================================
		# process command line
		#=============================================================================================
		parser = argparse.ArgumentParser(description='automatically generates the DHCP and TFTP configuration for registered machines in LDAP.')
		parser.add_argument('--dhcp', dest='dhcpdir', help='set the DHCP config directory', metavar='dhcpdir')
		parser.add_argument('--tftp', dest='tftpdir', help='set the TFTP root directory', metavar='tftpdir')
		parser.add_argument('--test', dest='test', action='store_true', help='verify a backup.')
		parser.add_argument('-v', '--verbose', dest='verbose', action='store_true', help='enable verbose output of this script.')

		args = parser.parse_args()
		self._initLog(args.verbose)

		if args.test is not None and args.test != False:
			pxe = PXEConfig(tftpdir='/tmp/tftproot', dhcpdir='/tmp/dhcp')
		else:
			pxe = PXEConfig(tftpdir=args.tftpdir, dhcpdir=args.dhcpdir)
		pxe.update_pxe_clients()
		pxe.create_boot_menu()

if __name__ == "__main__":
	app =  PXEConfigApp()
	app.main()

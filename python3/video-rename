#!/usr/bin/python3
# -*- coding: utf-8 -*-
# kate: space-indent on; indent-width 4; mixedindent off; indent-mode python; syntax Python;

import sys
import argparse
import json
import re
import string
import urllib.request
import datetime

from arsoft.utils import *
from arsoft.inifile import IniFile

re_words = re.compile('[ \\.\\-&_,]+')

def isxdigit(value):
    for c in value:
        if c not in string.hexdigits:
            return False
    return True

def iscamelcase(s):
    ret = False
    got_upper = False
    for c in s:
        if c in string.ascii_uppercase:
            if got_upper:
                # already upper, so at least two uppercase letters
                return False
            else:
                got_upper = True
        else:
            if not c in string.ascii_lowercase:
                return False
            got_upper = False
    return True

def split_camelcase(s):
    ret = []
    got_upper = False
    start = 0
    i = 0
    for i in range(len(s)):
        if s[i] in string.ascii_uppercase:
            if i > start:
                ret.append(s[start:i])
            got_upper = True
            start = i
    if i >= start:
        ret.append(s[start:])
    return ret

def convert_date(words):
    ret = []
    int_values = []
    month_names = ['january', 'february', 'march', 'april', 'may', 'june', 'july', 'august', 'september', 'october', 'november', 'december']
    for w in words:
        w_int = None
        w_int_month = False
        w_int_year = False
        try:
            w_int = month_names.index(w.lower()) + 1
            w_int_month = True
        except ValueError:
            pass
        if w_int is None:
            try:
                w_int = int(w)
                if w_int > 2000:
                    w_int_year = True
            except ValueError:
                pass
        ret.append(w)

        #print(w, w_int)
        if w_int is None:
            int_values = []
        else:
            int_values.append( (w_int, w_int_month, w_int_year) )
            if len(int_values) == 3:
                year = 0
                month = 0
                day = 0
                #print(int_values)
                for (w_int, w_int_month, w_int_year) in int_values:
                    if w_int_month:
                        month = w_int
                    elif w_int_year:
                        year = w_int

                for (w_int, w_int_month, w_int_year) in int_values:
                    if w_int_month or w_int_year:
                        continue
                    else:
                        if year == 0:
                            year = w_int + 2000 if w_int < 100 else w_int
                        elif month == 0 and w_int >= 1 and w_int <= 12:
                            month = w_int
                        elif day == 0 and w_int >= 1 and w_int <= 31:
                            day = w_int
                #print(year, month , day)
                if year and month and day:
                    # remove string values
                    ret = ret[0:-3]
                    ret.append(datetime.date(year=year, month=month, day=day))
                #print(int_values)
    return ret

def replace_in_list(list, needle, replacement):
    start = -1
    end = 0
    #print(list)
    for n in needle:
        try:
            i = list.index(n, end)
            if start < 0:
                start = i
            end = i
            #print('find %s -> %i' % (n, i))
        except ValueError:
            return list
    #print('build %i, %s -> %s -> %s' % (start, list[0:start], replacement, list[start+len(needle):]))
    list = list[0:start] + replacement + list[start+len(needle):]
    return list

def remove_ignored(words, ignored):
    if not words:
        return []
    ret = []
    index = 0
    words_len = len(words)
    #print('remove_ignored %s' % words)
    while index < words_len:
        found = False
        for iw in ignored:
            if isinstance(iw, list):
                offset = 0
                found = True
                #print('ff %s' % iw)
                for iwe in iw:
                    #print('ff qq %s<>%s' % (iwe, words[index+offset]))
                    if index+offset >= words_len or iwe != words[index+offset]:
                        found = False
                        break
                    offset = offset + 1
                #print('ff match %s' % found)
                if found:
                    index = index + len(iw)
            elif iw == words[index]:
                #print('ff match single %s' % iw)
                found = True
                index = index + 1
                break
        if not found:
            ret.append(words[index])
            index = index + 1
    #print('remove_ignored ret=%s' % ret)
    return ret

def split_into_words(s, ignored=None, combined=None):
    #print(s)
    ret = []
    ex = []
    in_brackets = 0
    brackets_list = []
    for w in re_words.split(s):
        if not w:
            continue
        if (w[0] == '(' and w[-1] == ')') or (w[0] == '[' and w[-1] == ']') or (w[0] == '{' and w[-1] == '}'):
            w = w[1:-1]
        elif w[0] == '(' or w[0] == '[':
            in_brackets+=1
            brackets_list.append(w[1:])
            continue
        elif w[-1] == ')' or w[0] == ']':
            in_brackets-=1
            brackets_list.append(w[0:-1])
            if in_brackets == 0:
                w = ' '.join(brackets_list)
            else:
                continue
        elif in_brackets > 0:
            brackets_list.append(w)
            continue

        if iscamelcase(w):
            for wx in split_camelcase(w):
                if wx[0].isalpha() and wx[-1].isdigit():
                    ex.append(wx[0:-1])
                elif wx[0].isalpha() and wx[-1] == '+':
                    ex.append(wx[0:-1])
                elif wx[0] == '#':
                    ex.append(wx[1:].lower())
                else:
                    ex.append(wx.lower())
        else:
            if w[0].isalpha() and w[-1].isdigit():
                ex.append(w[0:-1])
            elif w[0].isalpha() and w[-1] == '+':
                ex.append(w[0:-1])
            elif w[0] == '#':
                ex.append(w[1:].lower())
            else:
                ex.append(w.lower())
    if ignored is not None:
        ret = remove_ignored(ex, ignored)
    else:
        ret = ex
    if combined:
        for (needle, replacement) in combined:
            ret = replace_in_list(ret, needle, replacement)
            #print('%s -> %s, %s' % (needle, replacement, ret))
    ret = convert_date(ret)
    return ret

def expanduser_dirs(*args):
    dirs = []
    for a in args:
        if a is None:
            continue
        if isinstance(a, list):
            for e in a:
                e = os.path.expanduser(e)
                dirs.append(os.path.abspath(e))
        else:
            a = os.path.expanduser(a)
            dirs.append(os.path.abspath(a))
    return dirs

def extract_html_title(data):
    from html.parser import HTMLParser
    class MyHTMLParser(HTMLParser):
        _path = []
        _title = None
        def handle_starttag(self, tag, attrs):
            self._path.append(tag)

        def handle_endtag(self, tag):
            self._path.pop()

        def handle_data(self, data):
            if len(self._path) > 1 and self._path[-1] == 'title':
                self._title = data

    parser = MyHTMLParser()
    parser.feed(data)
    return parser._title

def copyfile(src, dst, *, follow_symlinks=True, callback=None, use_sendfile=False):
    """Copy data from src to dst.

    If follow_symlinks is not set and src is a symbolic link, a new
    symlink will be created instead of copying the file it points to.

    """
    if shutil._samefile(src, dst):
        raise shutil.SameFileError("{!r} and {!r} are the same file".format(src, dst))

    for fn in [src, dst]:
        try:
            st = os.stat(fn)
        except OSError:
            # File most likely does not exist
            pass
        else:
            # XXX What about other special files? (sockets, devices...)
            if shutil.stat.S_ISFIFO(st.st_mode):
                raise shutil.SpecialFileError("`%s` is a named pipe" % fn)

    if not follow_symlinks and os.path.islink(src):
        os.symlink(os.readlink(src), dst)
    else:
        size = os.stat(src).st_size
        with open(src, 'rb') as fsrc:
            with open(dst, 'wb') as fdst:
                copyfileobj(fsrc, fdst, callback=callback, total=size, use_sendfile=use_sendfile)
    return dst


def copyfileobj(fsrc, fdst, callback, total, length=4096*1024, flush_blocks=64, use_sendfile=False):
    copied = 0
    num_blocks = 0
    if use_sendfile:
        dest_fd = fdst.fileno()
        src_fd = fsrc.fileno()
        block_size = length * flush_blocks
        while True:
            bytesSent = os.sendfile(dest_fd, src_fd, copied, block_size)
            if bytesSent == 0:
                break
            copied += bytesSent
            if callback is not None:
                callback(copied, total=total)
    else:
        while True:
            buf = fsrc.read(length)
            if not buf:
                break
            fdst.write(buf)
            copied += len(buf)
            num_blocks += 1
            if num_blocks >= flush_blocks:
                fdst.flush()
                os.fsync(fdst.fileno())
                num_blocks = 0
            if callback is not None:
                callback(copied, total=total)


def copy_with_progress(src, dst, *, follow_symlinks=True, callback=None, use_sendfile=False):
    if os.path.isdir(dst):
        dst = os.path.join(dst, os.path.basename(src))
    copyfile(src, dst, follow_symlinks=follow_symlinks, callback=callback, use_sendfile=use_sendfile)
    shutil.copymode(src, dst, follow_symlinks=follow_symlinks)
    shutil.copystat(src, dst, follow_symlinks=follow_symlinks)
    return dst

def is_within_directory(f, d):
    relpath = os.path.relpath(f, d)
    if os.path.isabs(relpath):
        # if we got an abspath then f cannot be within d, otherwise we
        # would have gotten a relpath
        return False, None
    else:
        # if relpath starts with .. the file is outside the directory
        if relpath[0] == '.' and relpath[1] == '.':
            return False, None
        else:
            return True, relpath

class video_rule(object):
    def __init__(self, re_pattern, url_template, options={}):
        self.re_pattern = re_pattern
        self.re = re.compile(re_pattern)
        self.url_template = url_template
        self.options = options

    def match(self, basename):
        return self.re.match(basename)

    def __repr__(self):
        return '\"%s\" -> %s' % (self.re_pattern, self.url_template)

class hash_directory(object):
    def __init__(self, path=None, opts=None):
        self.path = path
        self.readonly = False
        if opts is not None:
            for o in opts.split(','):
                if o == 'read-only' or o == 'ro':
                    self.readonly = True

    def __str__(self):
        if self.readonly:
            return 'read-only:%s' % self.path
        else:
            return self.path

    def __repr__(self):
        return self.__str__()

class hash_entry(object):
    def __init__(self, base=None, opts=None, words=None):
        self._aliases = []
        if words is None:
            self._words = split_into_words(base)
        else:
            self._words = words
        self.directory = base
        self.debug = False
        if opts is not None:
            for o in opts.split(','):
                if ':' in o:
                    k,v = o.split(':')
                    if k == 'alias':
                        self._aliases.append(split_into_words(v))
                elif o == 'debug':
                    self.debug = True

    def equal(self, words):
        if len(words) != len(self._words):
            return False
        for i, w in enumerate(self._words):
            if w != words[i]:
                return False
        return True

    @property
    def aliases(self):
        return self._aliases

    @staticmethod
    def _match_words(lhs_words, rhs_words, full_match=False, partial_match=False, debug=False):

        ret = -1
        first = True
        i = 0
        i_max = len(lhs_words)
        j_max = len(rhs_words)
        num_matches = 0
        while i < i_max:
            rhs_words_start = 0
            while rhs_words_start < j_max and i < i_max:
                try:
                    #print('rhs_words.index(%s i=%i, %i)' % (lhs_words, i, rhs_words_start))
                    j = rhs_words.index(lhs_words[i], rhs_words_start)
                    if first:
                        ret = 1
                        num_matches += 1
                        first = False
                    else:
                        ret += 1
                    rhs_words_start = j + 1
                    #print(j)
                    k = 1
                    while i + k < i_max and j + k < j_max and lhs_words[i + k] == rhs_words[j + k]:
                        if debug:
                            print('xx k=%i, %s, %s' % (k, lhs_words[i + k], rhs_words[j + k]))
                        ret += 10
                        num_matches += 1
                        k += 1
                        if debug:
                            print('xx ret=%i' % (ret))
                    # add extra point for full match for single words
                    if i_max == 1:
                        ret += 1
                        if debug:
                            print('full i=%i/%i, ret=%i' % (i,i_max, ret))
                    i = i + k
                except ValueError:
                    break
            i += 1
        if full_match:

            if j_max == num_matches:
                if debug:
                    print('%s<>%s ret=%i (full match)' % (lhs_words,rhs_words,ret))
                return ret
            else:
                if debug:
                    print('%s<>%s ret=-1 (no full match %i!=%i)' % (lhs_words,rhs_words,j_max,num_matches))
                return -1
        elif partial_match:
            if num_matches >= i_max:
                if debug:
                    print('%s<>%s ret=%i (partial match)' % (lhs_words,rhs_words,ret))
                return ret
            else:
                if debug:
                    print('%s<>%s ret=-1 (no partial match %i!=%i)' % (lhs_words,rhs_words,i_max,num_matches))
                return -1
        else:
            if debug:
                print('%s<>%s %i/%i ret=%i' % (lhs_words,rhs_words,j_max,num_matches, ret))
            return ret

    def match(self, words, full_match=False, partial_match=False, debug=False):
        if self.debug:
            debug = True
        ret = self._match_words(self._words, words, full_match=full_match, partial_match=partial_match, debug=debug)
        for alias in self._aliases:
            alias_score = self._match_words(alias, words, full_match=full_match, partial_match=partial_match, debug=debug)
            if alias_score > ret:
                ret = alias_score
        return ret

    def __eq__(self, rhs):
        return self._words == rhs._words

    def __hash__(self):
        ret = 0
        for w in self._words:
            ret += hash(w)
        return ret

    def __iter__(self):
        return iter(self._words)

    @staticmethod
    def directory_name(words, delim='.'):
        s = []
        for w in words:
            if isinstance(w, datetime.date):
                s.append(str(w))
            else:
                s.append(w)
        return delim.join(s)

    def __str__(self):
        return self.directory_name(self._words)

    def __repr__(self):
        return self.__str__()

class input_file(object):
    def __init__(self, filename, hash_dir=None, entry=None, unknown=False, channels=False):
        self.hash_dir = hash_dir
        self.entry = entry
        self.filename = filename
        self.unknown = unknown
        self.channels = channels
        if not isinstance(self.filename, str):
            raise RuntimeError("self.filename is not a string: %s" % type(self.filename))
    def __str__(self):
        return self.filename
    def __repr__(self):
        return self.__str__()

class video_rename_app:
    def __init__(self):
        self._verbose = False
        self._files = []
        self._video_file_exts = []
        self._rules = []
        self._hash_threshold = 2
        self._hash_unknown_dir = '_unknown'
        self._hashes = []
        self._input_dirs = []
        self._hash_dirs = []
        self._ignored_words = []
        self._combined_words = []
        self._channels = []

    def _load_rules(self, section=None):
        self._rules = []
        for (k,v) in section.get_all():
            if k is None or not '.' in k:
                continue
            k_name, k_ext = k.split('.', 1)
            if k_ext == 're':
                re_pattern = v
                url = section.get(k_name + '.url')
                webpage = section.getAsBoolean(k_name + '.webpage', False)
                enable = section.getAsBoolean(k_name + '.enable', True)
                if url and enable:
                    options = { 'webpage': webpage }
                    r = video_rule(re_pattern, url, options)
                    self._rules.append(r)

    def _load_hashes(self, section):
        self._hashes = []
        for (k,v) in section.get_all():
            if k is None:
                continue
            self._hashes.append(hash_entry(k, v))
        self._hash_unknown_dir = section.get('unknown', '_unknown')
        self._hash_channels_dir = section.get('channels', '_channels')

    def _load_config(self, filename):
        filename = os.path.expanduser(filename)
        f = IniFile(filename, keyValueSeperator='=')
        if f.has_section('rules'):
            self._load_rules(f.section('rules'))
        if f.has_section('hashes'):
            self._load_hashes(f.section('hashes'))

        if self._input_dirs is None or not self._input_dirs:
            self._input_dirs = f.getAsArray(None, 'input')
        if self._hash_dirs is None or not self._hash_dirs:
            self._hash_dirs = []
            for hd in f.getAsArray(None, 'hash_dir'):
                if ',' in hd:
                    path,opts = hd.split(',',1)
                else:
                    path = hd
                    opts = None
                self._hash_dirs.append(hash_directory(path, opts))

        self._video_file_exts = f.getAsArray(None, 'video_file_exts', ['.mp4', '.avi', '.wmv', '.mkv', '.mov', '.vid'])
        self._ignored_words = []
        ignored_words_multi = []
        for w in f.getAsArray(None, 'ignored_words', ['360p', '480p', '720p', '1080p', 'and', 'the', 'a', 'is', 'in', 'of']):
            ww = split_into_words(w)
            if len(ww) > 1:
                #print('ignore %s' % (ww))
                ignored_words_multi.append(ww)
            else:
                self._ignored_words.append(w)
        # put all multi words ignores to the beginning of the list
        for ww in ignored_words_multi:
            self._ignored_words.insert(0, ww)
        self._channels = f.getAsArray(None, 'channels', [])
        for s in self._channels:
            channel_names = s.split(',')
            main_channel_name = channel_names[0]
            for ch in channel_names:
                chw = split_into_words(ch)
                self._combined_words.append( (chw, [main_channel_name] ) )

    def _add_file(self, f):
        fabs = os.path.abspath(f.filename)
        (name, ext) = os.path.splitext(fabs)
        if ext in self._video_file_exts:
            self._files.append(input_file(fabs, hash_dir=f.hash_dir, unknown=f.unknown, channels=f.channels, entry=f.entry))
        elif self._verbose:
            print('Skip non-video file %s' % fabs)

    def _add(self, f):
        if not isinstance(f, input_file):
            raise RuntimeError('require input_file not %s' % type(f))
        if self._verbose:
            print('Process %s' % f)

        if os.path.isfile(f.filename):
            self._add_file(f)
        elif os.path.isdir(f.filename):
            for e in os.listdir(path=f.filename):
                full = os.path.join(f.filename, e)
                if os.path.isdir(full):
                    self._add( input_file(full, hash_dir=f.hash_dir, unknown=f.unknown, channels=f.channels, entry=f.entry) )
                elif os.path.isfile(full):
                    self._add_file(input_file(full, hash_dir=f.hash_dir, unknown=f.unknown, channels=f.channels, entry=f.entry))

    def _mkdir(self, d):
        ret = True
        if not os.path.isdir(d):
            try:
                os.makedirs(d, exist_ok=True)
            except OSError:
                ret = False
        return ret


    def _rename_file(self, src, dst, overwrite=False):
        ret = False
        dst_dir = os.path.dirname(dst)
        self._mkdir(dst_dir)
        need_copy = False
        try:
            do_rename = True
            if os.path.exists(dst):
                if os.path.islink(dst):
                    target = os.readlink(dst)
                    if not os.path.isabs(target):
                        # convert into absolute path
                        target = os.path.join(os.path.dirname(dst), target)
                    if os.path.samefile(src,target):
                        os.remove(dst)
                        #print('Found link from src to dst -> %s' % dst)
                elif os.path.isdir(dst):
                    print('Destination %s exists as directory' % (dst), file=sys.stderr)
                    do_rename = False
                elif os.path.isfile(dst):
                    if overwrite:
                        print('Destination file %s already exists. Overwrite' % (dst), file=sys.stderr)
                        os.remove(dst)
                    else:
                        do_rename = False
                        print('Destination file %s already exists' % (dst), file=sys.stderr)
                else:
                    print('Destination %s already exists' % (dst), file=sys.stderr)
                    do_rename = False
            if do_rename:
                os.rename(src, dst)
            ret = True
        except OSError as e:
            # Invalid cross-device link
            if e.errno == 18:
                need_copy = True
            else:
                print('Failed to rename %s to %s: %s' % (src, dst, e), file=sys.stderr)
        if need_copy:
            def _copy_progress(copied, total):
                precent = 100*copied/total
                print('\r  Copying %i %% ...' % (precent), end='')
            try:
                print("  Copying", end='')
                copy_with_progress(src, dst, callback=_copy_progress, use_sendfile=False if self._disable_sendfile else True)
                #shutil.copy2(src, dst)
                os.unlink(src)
                ret = True
                print("\r  Copy complete")
            except OSError as e:
                print('Failed to copy %s to %s: %s' % (src, dst, e), file=sys.stderr)
        return ret

    def _mklink(self, src, dst):
        ret = False
        dst_dir = os.path.dirname(dst)
        self._mkdir(dst_dir)
        r = os.path.relpath(src, dst_dir)
        try:
            if os.path.islink(dst):
                # remove old link first
                os.remove(dst)
            os.symlink(r, dst, target_is_directory=False)
            ret = True
        except OSError as e:
            print('Failed to create symlink %s to %s: %s' % (src, dst, e), file=sys.stderr)
        return ret

    def _get_html_title(self, url):

        hdr = {'User-Agent':'Mozilla/5.0', 'Accept': '*/*'}
        req = urllib.request.Request(url, headers=hdr)
        try:
            response = urllib.request.urlopen(req)
            if response.status == 200:
                data = response.read()      # a `bytes` object
                text = data.decode('utf-8') # a `str`; this step can't be used if data is binary
                #print(text)
                return extract_html_title(text)
            #elif response.status == 302:
                #newurl = response.geturl()
                #print('new url %s' % newurl)
        except urllib.error.HTTPError as e:
            if self._verbose:
                print('HTTP Error %s: %s' % (url, e))
            pass
        return None

    def _clean_title(self, s):
        hash_idx = s.rfind('#')
        if hash_idx > 0:
            s = s[0:hash_idx - 1]
        s = self._clean_filename(s)
        words = split_into_words(s, ignored=self._ignored_words, combined=self._combined_words)
        if self._verbose:
            print('clean filename %s: %s' % (s, words))
        if not words:
            return None

        while len(s) > 200:
            elems = s.split()
            elems.pop()
            s = ' '.join(elems)
        return s

    def _clean_filename(self, s):
        s = s.replace('/', '_')
        s = s.replace('\r', '_')
        s = s.replace('\n', '_')
        s = s.replace('__', '_')
        s = s.strip()
        return s

    def _auto_rename_file(self, f, force=False):
        if not isinstance(f, input_file):
            raise RuntimeError('require input_file not %s' % type(f))
        path, name = os.path.split(f.filename)
        (basename, ext) = os.path.splitext(name)

        found_rule = False
        found_url = None
        for rule in self._rules:
            m = rule.match(basename)
            if m is not None:
                found_rule = True
                found_url = m.expand(rule.url_template)
                if self._verbose:
                    print('  %s: Match rule %s/%s -> %s' % (basename, rule.re_pattern, rule.url_template, found_url))
                break
        got_title = False
        suggested_filename = None

        if found_rule:
            try:
                (sts, stdoutdata, stderrdata) = runcmdAndGetData(args=['ffprobe', '-hide_banner', '-v', 'error', '-of', 'json', '-show_format', f.filename])
            except FileNotFoundError as ex:
                print('Cannot execute ffprobe.', file=sys.stderr)
                sts = -1
            if sts == 0:
                file_format = json.loads(stdoutdata.decode('utf8'))
                #print(file_format['format'])
                if 'tags' in file_format['format']:
                    tags = file_format['format']['tags']
                    if 'title' in tags:
                        title = self._clean_title(tags['title'])
                        if title:
                            got_title = True
                            suggested_filename = path + '/' + title + ext
            if not got_title and found_url:
                title = self._get_html_title(found_url)
                if title:
                    title = self._clean_title(title)
                    if title:
                        suggested_filename = path + '/' + title + ('.%s' % basename) + ext
        else:
            new_basename = self._clean_filename(basename)
            if new_basename != basename:
                suggested_filename = path + '/' + new_basename + ext

        if suggested_filename is not None:
            if self._noop:
                print('  Rename to %s (noop)' % (suggested_filename))
            else:
                print('  Rename to %s' % (suggested_filename))
                self._rename_file(f.filename, suggested_filename)
        return suggested_filename

    def _find_hash_entry(self, basename, existing_entry=None, full_match=False, debug=False):
        words = split_into_words(basename, ignored=self._ignored_words, combined=self._combined_words)

        ret = []
        for e in self._hashes:
            score = e.match(words, full_match=full_match, debug=debug)
            if score >= 0:
                ret.append((score, e))
        ret = sorted(ret, key=lambda e: e[0], reverse=True)
        if ret and existing_entry is not None:
            (top_score, top_entry) = ret[0]
            ret.insert(0, (top_score, existing_entry) )
        return ret

    def _auto_hash_file(self, f, force=False):
        if not isinstance(f, input_file):
            raise RuntimeError('require input_file not %s' % type(f))
        path, name = os.path.split(f.filename)
        (basename, ext) = os.path.splitext(name)

        suggested_filename = None
        symlink_filenames = []
        equal_score_entries = []
        entries = self._find_hash_entry(basename, existing_entry=f.entry, debug=False)
        if entries:
            entries = filter(lambda x: x[0] >= self._hash_threshold, entries)
        if entries:
            is_unknown = False
            equal_score = None
            equal_score_entries = []
            for (score, e) in entries:
                if equal_score is None:
                    equal_score = score
                    equal_score_entries.append(e)
                elif equal_score == score:
                    equal_score_entries.append(e)

        if equal_score_entries:
            dest_filenames = []
            for e in equal_score_entries:
                if f.hash_dir is None:
                    for hd in self._hash_dirs:
                        if hd.readonly:
                            continue
                        suggested_dir = os.path.join(hd.path, e.directory)
                        new_filename = os.path.join(suggested_dir, name)
                        dest_filenames.append( (new_filename, hd) )
                else:
                    suggested_dir = os.path.join(f.hash_dir.path, e.directory)
                    new_filename = os.path.join(suggested_dir, name)
                    dest_filenames.append( (new_filename, f.hash_dir) )

            if dest_filenames:
                if self._verbose:
                    print('  dest filenames: %s' % (dest_filenames))
                for (new_filename, hd) in dest_filenames:
                    is_same = False
                    try:
                        is_same = os.path.samefile(new_filename, f.filename)
                    except OSError:
                        pass
                    if is_same:
                        suggested_filename = new_filename
                    else:
                        symlink_filenames.append(new_filename)
                if suggested_filename is None:
                    suggested_filename = symlink_filenames[0]
                    if len(symlink_filenames) > 1:
                        symlink_filenames = symlink_filenames[1:]
                    else:
                        symlink_filenames = []

        if suggested_filename is None:
            # DO not move files if the file is within a hash_dir
            is_within_hash_dir = False
            if f.hash_dir is None:
                for hd in self._hash_dirs:
                    is_within_hash_dir, relpath = is_within_directory(f.filename, hd.path)
                    if is_within_hash_dir:
                        break
            else:
                is_within_hash_dir = True
            if not is_within_hash_dir:
                target_hd = None
                for hd in self._hash_dirs:
                    if hd.readonly:
                        continue
                    target_hd = hd
                    break
                if target_hd is not None:
                    suggested_filename = os.path.join(target_hd.path, self._hash_unknown_dir, name)

        if suggested_filename is not None:
            if f.filename != suggested_filename:
                if self._noop:
                    print('  Hash move to %s (noop)' % (suggested_filename))
                else:
                    print('  Hash move to %s' % (suggested_filename))
                    self._rename_file(f.filename, suggested_filename)

            for f in symlink_filenames:
                if self._noop:
                    print('  Hash symlink to %s (noop)' % (f))
                else:
                    print('  Hash symlink to %s' % (f))
                    self._mklink(suggested_filename, f)

    def _is_combined_word(self,w):
        ret = False
        for (chw, main_channel_name) in self._combined_words:
            if w in chw:
                ret = True
                break
        return ret

    def main(self):
        #=============================================================================================
        # process command line
        #=============================================================================================
        parser = argparse.ArgumentParser(description='renames video files by extract the video title from the meta data')
        parser.add_argument('-v', '--verbose', dest='verbose', action='store_true', help='enable verbose output of this script.')
        parser.add_argument('-d', '--debug', dest='debug', action='store_true', help='enable debug output of this script.')
        parser.add_argument('-f', '--force', dest='force', action='store_true', help='force processing of given files.')
        parser.add_argument('-n', '--noop', dest='noop', action='store_true', help='only show what would be done.')
        parser.add_argument('--no-hash', dest='no_hash', action='store_true', help='do not perform hashing')
        parser.add_argument('--no-rename', dest='no_rename', action='store_true', help='do not rename files.')
        parser.add_argument('-H', '--hash', dest='hash_dirs', nargs='*', help='hash video files into given directory')
        parser.add_argument('-q', '--query', dest='queries', nargs='*', help='query for specific files')
        parser.add_argument('-r', '--rehash', dest='rehashs', nargs='*', help='rehash specific words')
        parser.add_argument('--unknown', dest='process_unknown', action='store_true', help='re-process files in unknown directory')
        parser.add_argument('--channels', dest='process_channels', action='store_true', help='re-process files in channels directory')
        parser.add_argument('-c', '--config', dest='config_file', default='~/.config/video-rename.conf', help='load configuration file')
        parser.add_argument('--test-words', dest='test_words', nargs='*', help='testing word processing')
        parser.add_argument('--test-match', dest='test_match', nargs='*', help='test match processing')
        parser.add_argument('--show-hashes', dest='show_hashes', action='store_true', help='show all configured hashes')
        parser.add_argument('--disable-sendfile', dest='disable_sendfile', action='store_true', help='disable usage of sendfile on Unix machines')
        parser.add_argument('files', metavar='FILE', type=str, nargs='*', help='video files or directories')

        args = parser.parse_args()
        self._verbose = args.verbose
        self._debug = args.debug
        self._noop = args.noop
        self._no_hash = args.no_hash
        self._no_rename = args.no_rename
        #self._noop = True
        self._input_dirs = args.files
        self._hash_dirs = []
        for h in expanduser_dirs(args.hash_dirs):
            self._hash_dirs.append(hash_directory(h))
        self._queries = args.queries
        self._rehashs = args.rehashs
        self._process_unknown = args.process_unknown
        self._process_channels = args.process_channels
        self._disable_sendfile = args.disable_sendfile

        self._load_config(filename=args.config_file)

        if self._debug:
            print('Rules:')
            for r in self._rules:
                print('  %s' % r)
        if args.show_hashes:
            print('Hashes:')
            for h in self._hashes:
                print('  %s' % h)
                if h.aliases:
                    for a in h.aliases:
                        print('    %s' % hash_entry.directory_name(a))

            print('Hash unknown dir: %s' % self._hash_unknown_dir)
            print('Hash channels dir: %s' % self._hash_channels_dir)
            return 0

        if args.test_words:
            if self._debug:
                print('Ignored words:')
                for w in self._ignored_words:
                    print('  %s' %w)
                print('Combined words:')
                for (chw, main_channel_name) in self._combined_words:
                    print('  %s -> %s' % ('.'.join(chw), '.'.join(main_channel_name)) )
            print('Results:')
            for w in args.test_words:
                if w.startswith('file://'):
                    w = w[7:]
                if os.path.exists(w):
                    (name, ext) = os.path.splitext(w)
                    w = os.path.basename(name)
                words = split_into_words(w, ignored=self._ignored_words, combined=self._combined_words)
                print('  %s' % words)
            return 0

        if args.test_match:
            for w in args.test_match:
                if w.startswith('file://'):
                    w = w[7:]
                if os.path.exists(w):
                    (name, ext) = os.path.splitext(w)
                    w = os.path.basename(name)
                entries = self._find_hash_entry(w, full_match=False, debug=self._debug)
                if entries:
                    entries = filter(lambda x: x[0] >= self._hash_threshold, entries)
                if entries:
                    for (score, e) in entries:
                        print('%03i %s' % (score, e))
            return 0

        input_dirs = []
        for f in expanduser_dirs(self._input_dirs):
            f_hd = None
            f_entry = None
            for hd in self._hash_dirs:
                within, relpath = is_within_directory(f, hd.path)
                if within:
                    if os.path.isfile(f):
                        f_dir = os.path.dirname(relpath)
                    else:
                        f_dir = relpath
                    #print('%i, %s' % (within, f_dir))
                    f_hd = hd
                    entries = self._find_hash_entry(f_dir, full_match=True)
                    if entries:
                        f_score, f_entry = entries[0]
                    break
            #print(f, f_hd, f_entry)
            input_dirs.append( input_file(f, hash_dir=f_hd, entry=f_entry) )
        if self._verbose:
            if input_dirs:
                print('Input:')
                for i in input_dirs:
                    print('  %s' % i)
            if not self._no_hash:
                print('Hash dirs:')
                for hd in self._hash_dirs:
                    print('  %s' % hd)

        if self._process_unknown or self._process_channels:
            input_dirs = []
        elif self._queries:
            # query is a read-only operation
            self._no_hash = True
            self._no_rename = True
        elif self._rehashs:
            input_dirs = []
            # rehash, so required to do some hashing, but no rename
            self._no_hash = False
            self._no_rename = True
        if self._process_unknown:
            for h in self._hash_dirs:
                input_dirs.append( input_file(os.path.join(h.path, self._hash_unknown_dir), hash_dir=h, unknown=True) )
        if self._process_channels:
            for h in self._hash_dirs:
                input_dirs.append( input_file(os.path.join(h.path, self._hash_channels_dir), hash_dir=h, channels=True) )

        for f in input_dirs:
            self._add(f)

        if self._verbose:
            print('Files to process:')
            for i, f in enumerate(self._files):
                print('  [%03i]: %s' % (i,f))

        possible_words = []
        show_possible_words = False

        if self._process_unknown or self._process_channels:
            show_possible_words = True
            word_dict = {}

            for f in self._files:
                (name, ext) = os.path.splitext(f.filename)
                basename = os.path.basename(name)
                words = split_into_words(basename, ignored=self._ignored_words, combined=self._combined_words)
                num_words = len(words)
                for i in range(num_words):
                    if i + 1 < num_words:
                        if self._is_combined_word(words[i]) or self._is_combined_word(words[i+1]):
                            continue
                        word_combo = [ words[i], words[i+1] ]
                        h = hash_entry( words=word_combo )
                        if h in word_dict:
                            word_dict[h].add(f)
                        else:
                            word_dict[h] = set( [ f ] )

            existing_hashes = []
            for (h, files) in word_dict.items():
                found_existing_hash = True if h in self._hashes else False

                if found_existing_hash:
                    existing_hashes.append( (h, files) )
                elif len(files) > 1: #self._hash_threshold:
                    possible_words.append( (h, files ) )

            if 0:
                # reset the list of files
                self._files = []
                if existing_hashes:
                    if self._verbose:
                        print('Find files for existing hashes:')
                    for (h, files) in existing_hashes:
                        if self._verbose:
                            print('  %s: %i matches' % (h, len(files)))
                        for f in files:
                            if self._verbose:
                                print('    %s' % f)
                            self._files.append(f)

                if self._verbose:
                    if self._files:
                        print('Files for rehashing:')
                        for f in files:
                            print('  %s' % f)
        elif self._queries:

            for q in self._queries:
                entries = self._find_hash_entry(q, full_match=True, debug=self._debug)
                if entries:
                    for (score, e) in entries:
                        print('Found hash entry \'%s\':' % (e))

                        results = []
                        for hd in self._hash_dirs:
                            d = os.path.join(hd.path, str(e))
                            if os.path.isdir(d):
                                for f in os.listdir(d):
                                    results.append( (f, os.path.join(d, f), hd ) )
                        for f in self._files:
                            (name, ext) = os.path.splitext(f.filename)
                            basename = os.path.basename(name)
                            words = split_into_words(basename, ignored=self._ignored_words, combined=self._combined_words)
                            score = e.match(words, full_match=False)
                            if score >= 0:
                                results.append( (basename, f.filename, None ) )

                        for (basename, full, hd) in sorted(results, key=lambda x: x[0]):
                            if hd is None:
                                print('  %s in %s' % (basename, os.path.dirname(full)))
                            else:
                                print('  %s' % basename)
                if 1:
                    tmp_hash_entry = hash_entry(q)
                    results = []
                    for hd in self._hash_dirs:
                        d = os.path.join(hd.path, self._hash_unknown_dir)
                        if os.path.isdir(d):
                            for f in os.listdir(d):
                                (basename, ext) = os.path.splitext(f)
                                words = split_into_words(basename, ignored=self._ignored_words, combined=self._combined_words)
                                score = tmp_hash_entry.match(words, partial_match=True)
                                if score >= 0:
                                    results.append( (f, os.path.join(d, f), hd ) )

                    for (basename, full, hd) in sorted(results, key=lambda x: x[0]):
                        print('  %s in %s' % (basename, os.path.dirname(full)))


        elif self._rehashs:
            for q in self._rehashs:
                entries = self._find_hash_entry(q, full_match=True)
                if entries:
                    for (score, e) in entries:
                        print('Found hash entry: %s:' % (e))
                        for hd in self._hash_dirs:
                            d = os.path.join(hd.path, str(e))
                            if os.path.isdir(d):
                                self._add(input_file(d, hash_dir=hd, entry=e))


        total = len(self._files)
        total_progress = 0
        current_progress = 0
        if not self._no_rename:
            total_progress += total
        if not self._no_hash:
            total_progress += total

        if not self._no_rename:
            for i in range(total):
                print('[%03i/%03i] Rename %s' % (current_progress + 1, total_progress, self._files[i]))
                current_progress += 1
                f_new = self._auto_rename_file(self._files[i], force=args.force)
                if f_new is not None:
                    self._files[i] = input_file(f_new, hash_dir=f.hash_dir)

        if not self._no_hash:
            for i in range(total):
                f = self._files[i]
                print('[%03i/%03i] Hash %s' % (current_progress + 1, total_progress, self._files[i]))
                current_progress += 1
                self._auto_hash_file(self._files[i], force=args.force)

        if possible_words and show_possible_words:
            possible_words = sorted(possible_words, key=lambda e: len(e[1]), reverse=False)
            print('Possible words:')
            for (h, files) in possible_words:
                print('  %s: %i matches' % (h, len(files)))
                if self._debug:
                    for f in files:
                        print('    %s' % f)
            for (h, files) in possible_words:
                if len(files) > 2:
                    print('%s=' % (h))
        ret = 0
        return ret

if __name__ == "__main__":
    app =  video_rename_app()
    sys.exit(app.main())

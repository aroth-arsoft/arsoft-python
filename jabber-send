#!/usr/bin/python
# -*- coding: utf-8 -*-
# kate: space-indent on; indent-width 4; mixedindent off; indent-mode python;

import os
import argparse
import sys
import logging
import time

(python_major, python_minor, python_micro, python_releaselevel, python_serial) = sys.version_info
if int(python_major) < 3: # check for version < 3
    from ConfigParser import ConfigParser
else:
    from configparser import ConfigParser
    
def sleekxmpp_send_message(sender, password, recipient, body, html=None, subject=None, message_type='chat',
                           ipv4=True, ipv6=True):
    from sleekxmpp import ClientXMPP
    #from sleekxmpp.exceptions import IqError, IqTimeout        
    class SendMsgBot(ClientXMPP):

        """
        A basic SleekXMPP bot that will log in, send a message,
        and then log out.
        """

        def __init__(self, jid, password, recipient, message, html=None, subject=None, message_type='chat',
                     ipv4=True, ipv6=True):
            ClientXMPP.__init__(self, jid, password)

            self.use_ipv6 = ipv6
            # The message we wish to send, and the JID that
            # will receive it.
            self.recipient = recipient
            self.subject = subject
            self.message = message
            self.html = html
            self.message_type = message_type
            self.message_sent = False

            # The session_start event will be triggered when
            # the bot establishes its connection with the server
            # and the XML streams are ready for use. We want to
            # listen for this event so that we we can initialize
            # our roster.
            self.add_event_handler("session_start", self.start, threaded=True)

        def start(self, event):
            """
            Process the session_start event.

            Typical actions for the session_start event are
            requesting the roster and broadcasting an initial
            presence stanza.

            Arguments:
                event -- An empty dictionary. The session_start
                        event does not provide any additional
                        data.
            """
            self.send_presence()
            self.get_roster()

            self.send_message(mto=self.recipient,
                              msubject=self.subject,
                              mbody=self.message,
                              mhtml=self.html,
                              mtype=self.message_type)

            # Using wait=True ensures that the send queue will be
            # emptied before ending the session.
            self.disconnect(wait=True)
            self.message_sent = True

    xmpp = SendMsgBot(sender, password, recipient, body, html, subject, message_type, ipv4=ipv4, ipv6=ipv6)
    xmpp.register_plugin('xep_0030') # Service Discovery
    xmpp.register_plugin('xep_0199') # XMPP Ping
    xmpp.connect(use_ssl=False, use_tls=True)
    xmpp.process(block=True)
    return xmpp.message_sent

class jabbersend:
    def __init__(self):
        self.verbose = False
        
    def main(self):
        #=============================================================================================
        # process command line
        #=============================================================================================
        parser = argparse.ArgumentParser(description='send messages using jabber')
        parser.add_argument('--configfile', dest='configfile', help='input config file')
        parser.add_argument('-v', '--verbose', dest='verbose', action='store_true', help='enable verbose output.')
        parser.add_argument('-m', '--message', dest='message', help='message body text', metavar='MSG')
        parser.add_argument('-s', '--subject', dest='subject', help='message subject', metavar='SUB')
        parser.add_argument('-f', '--from', dest='sender', help='sender name')
        parser.add_argument('-t', '--to', dest='recipient', help='recipient name')
        parser.add_argument('-p', '--password', dest='password', help='password for sender')
        parser.add_argument('-4', dest='ipv4', default=False, action='store_true', help='only use IPv4 to connect to server.')
        parser.add_argument('-6', dest='ipv6', default=False, action='store_true', help='only use IPv6 to connect to server.')

        args = parser.parse_args()
        
        sender = None
        recipient = None
        password = None
        subject = args.subject
        self.verbose = args.verbose
        
        if self.verbose:
            logger.setLevel(logging.DEBUG) # change to DEBUG for higher verbosity

        if args.configfile:
            config = ConfigParser.ConfigParser()
            config.read(args.configfile)

            sender = config.get('General', 'From', '') 
            recipient = config.get('General', 'To', '') 
            password = config.get('General', 'Password', '') 
        
        if args.sender:
            sender = args.sender
        if args.recipient:
            recipient = args.recipient
        if args.password:
            password = args.password

        if not sender:
            sys.stderr.write('No sender specified.\n') 
            return 1
        if not recipient:
            sys.stderr.write('No recipient specified.\n') 
            return 1

        if args.message:
            body = args.message
        else:
            body = sys.stdin.read()

        if not body:
            sys.stderr.write('No message given.\n') 
            return 1

        if self.verbose:
            print('Send message \'%s\' from %s to %s' %(body, sender, recipient))
        if sleekxmpp_send_message(sender, password, recipient, body, subject, 
                                  ipv4=(True if args.ipv6 == False else False),
                                  ipv6=(True if args.ipv4 == False else False)):
            ret = 0
        else:
            sys.stderr.write('Failed to send message from %s to %s.\n' %(sender, recipient))
            ret = 1
        return ret

if __name__ == "__main__":
    # PyXMPP uses `logging` module for its debug output
    # applications should set it up as needed
    logger = logging.getLogger()
    logger.addHandler(logging.StreamHandler())

    app =  jabbersend()
    sys.exit(app.main())
